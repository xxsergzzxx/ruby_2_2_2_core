<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.33.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : Array  -   Ruby 2.2.2 ' />
  <meta content="2015-04-26 10:44:32 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = false-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: Array (Ruby 2.2.2) </title>
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >

  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

</head>

<body id="top" class="class rdocstar">
<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
<!-- VERSION HEADER for 2.2.2 NOT FOUND --></div> <!-- end action bar -->
 <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>array.c</li>      
            
          
          <li class='in-file'>pack.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-5B-5D">::[]</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-try_convert">::try_convert</a></li>
          
          <li><a href="#method-i-26">#&</a></li>
          
          <li><a href="#method-i-2A">#*</a></li>
          
          <li><a href="#method-i-2B">#+</a></li>
          
          <li><a href="#method-i-2D">#-</a></li>
          
          <li><a href="#method-i-3C-3C">#<<</a></li>
          
          <li><a href="#method-i-3C-3D-3E">#<=></a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-any-3F">#any?</a></li>
          
          <li><a href="#method-i-assoc">#assoc</a></li>
          
          <li><a href="#method-i-at">#at</a></li>
          
          <li><a href="#method-i-bsearch">#bsearch</a></li>
          
          <li><a href="#method-i-clear">#clear</a></li>
          
          <li><a href="#method-i-collect">#collect</a></li>
          
          <li><a href="#method-i-collect-21">#collect!</a></li>
          
          <li><a href="#method-i-combination">#combination</a></li>
          
          <li><a href="#method-i-compact">#compact</a></li>
          
          <li><a href="#method-i-compact-21">#compact!</a></li>
          
          <li><a href="#method-i-concat">#concat</a></li>
          
          <li><a href="#method-i-count">#count</a></li>
          
          <li><a href="#method-i-cycle">#cycle</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-delete_at">#delete_at</a></li>
          
          <li><a href="#method-i-delete_if">#delete_if</a></li>
          
          <li><a href="#method-i-drop">#drop</a></li>
          
          <li><a href="#method-i-drop_while">#drop_while</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_index">#each_index</a></li>
          
          <li><a href="#method-i-empty-3F">#empty?</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-fetch">#fetch</a></li>
          
          <li><a href="#method-i-fill">#fill</a></li>
          
          <li><a href="#method-i-find_index">#find_index</a></li>
          
          <li><a href="#method-i-first">#first</a></li>
          
          <li><a href="#method-i-flatten">#flatten</a></li>
          
          <li><a href="#method-i-flatten-21">#flatten!</a></li>
          
          <li><a href="#method-i-frozen-3F">#frozen?</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-index">#index</a></li>
          
          <li><a href="#method-i-initialize_copy">#initialize_copy</a></li>
          
          <li><a href="#method-i-insert">#insert</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-join">#join</a></li>
          
          <li><a href="#method-i-keep_if">#keep_if</a></li>
          
          <li><a href="#method-i-last">#last</a></li>
          
          <li><a href="#method-i-length">#length</a></li>
          
          <li><a href="#method-i-map">#map</a></li>
          
          <li><a href="#method-i-map-21">#map!</a></li>
          
          <li><a href="#method-i-pack">#pack</a></li>
          
          <li><a href="#method-i-permutation">#permutation</a></li>
          
          <li><a href="#method-i-pop">#pop</a></li>
          
          <li><a href="#method-i-product">#product</a></li>
          
          <li><a href="#method-i-push">#push</a></li>
          
          <li><a href="#method-i-rassoc">#rassoc</a></li>
          
          <li><a href="#method-i-reject">#reject</a></li>
          
          <li><a href="#method-i-reject-21">#reject!</a></li>
          
          <li><a href="#method-i-repeated_combination">#repeated_combination</a></li>
          
          <li><a href="#method-i-repeated_permutation">#repeated_permutation</a></li>
          
          <li><a href="#method-i-replace">#replace</a></li>
          
          <li><a href="#method-i-reverse">#reverse</a></li>
          
          <li><a href="#method-i-reverse-21">#reverse!</a></li>
          
          <li><a href="#method-i-reverse_each">#reverse_each</a></li>
          
          <li><a href="#method-i-rindex">#rindex</a></li>
          
          <li><a href="#method-i-rotate">#rotate</a></li>
          
          <li><a href="#method-i-rotate-21">#rotate!</a></li>
          
          <li><a href="#method-i-sample">#sample</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-select-21">#select!</a></li>
          
          <li><a href="#method-i-shift">#shift</a></li>
          
          <li><a href="#method-i-shuffle">#shuffle</a></li>
          
          <li><a href="#method-i-shuffle-21">#shuffle!</a></li>
          
          <li><a href="#method-i-size">#size</a></li>
          
          <li><a href="#method-i-slice">#slice</a></li>
          
          <li><a href="#method-i-slice-21">#slice!</a></li>
          
          <li><a href="#method-i-sort">#sort</a></li>
          
          <li><a href="#method-i-sort-21">#sort!</a></li>
          
          <li><a href="#method-i-sort_by-21">#sort_by!</a></li>
          
          <li><a href="#method-i-take">#take</a></li>
          
          <li><a href="#method-i-take_while">#take_while</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-to_ary">#to_ary</a></li>
          
          <li><a href="#method-i-to_h">#to_h</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-transpose">#transpose</a></li>
          
          <li><a href="#method-i-uniq">#uniq</a></li>
          
          <li><a href="#method-i-uniq-21">#uniq!</a></li>
          
          <li><a href="#method-i-unshift">#unshift</a></li>
          
          <li><a href="#method-i-values_at">#values_at</a></li>
          
          <li><a href="#method-i-zip">#zip</a></li>
          
          <li><a href="#method-i-7C">#|</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="Enumerable.html">Enumerable</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id='files'>
        
          
          <li class="file"><a href="./_lib/racc/rdoc/grammar_en_rdoc.html">grammar.en.rdoc</a></li>
        
          
          <li class="file"><a href="./_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributing_rdoc.html">contributing.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributors_rdoc.html">contributors.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/dtrace_probes_rdoc.html">dtrace_probes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/globals_rdoc.html">globals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/keywords_rdoc.html">keywords.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/maintainers_rdoc.html">maintainers.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/marshal_rdoc.html">marshal.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/regexp_rdoc.html">regexp.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/security_rdoc.html">security.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/standard_library_rdoc.html">standard_library.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax_rdoc.html">syntax.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/assignment_rdoc.html">assignment.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/calling_methods_rdoc.html">calling_methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/control_expressions_rdoc.html">control_expressions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/exceptions_rdoc.html">exceptions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/literals_rdoc.html">literals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/methods_rdoc.html">methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/miscellaneous_rdoc.html">miscellaneous.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/modules_and_classes_rdoc.html">modules_and_classes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/precedence_rdoc.html">precedence.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/refinements_rdoc.html">refinements.rdoc</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_ja_rdoc.html">README.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_rdoc.html">README.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="./Array.html">Array</a></li>
        
          
          
          <li><a href="./BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="./Bignum.html">Bignum</a></li>
        
          
          
          <li><a href="./Binding.html">Binding</a></li>
        
          
          
          <li><a href="./Class.html">Class</a></li>
        
          
          
          <li><a href="./Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="./Complex.html">Complex</a></li>
        
          
          
          <li><a href="./Complex/compatible.html">Complex::compatible</a></li>
        
          
          
          <li><a href="./ConditionVariable.html">ConditionVariable</a></li>
        
          
          
          <li><a href="./Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="./Data.html">Data</a></li>
        
          
          
          <li><a href="./Dir.html">Dir</a></li>
        
          
          
          <li><a href="./ENV.html">ENV</a></li>
        
          
          
          <li><a href="./EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="./Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="./Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="./Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="./Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="./Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="./Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="./EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="./Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="./Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="./Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="./Enumerator/Lazy.html">Enumerator::Lazy</a></li>
        
          
          
          <li><a href="./Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="./Errno.html">Errno</a></li>
        
          
          
          <li><a href="./Exception.html">Exception</a></li>
        
          
          
          <li><a href="./FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="./Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="./FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="./File.html">File</a></li>
        
          
          
          <li><a href="./File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="./File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="./FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="./Fixnum.html">Fixnum</a></li>
        
          
          
          <li><a href="./Float.html">Float</a></li>
        
          
          
          <li><a href="./FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="./GC.html">GC</a></li>
        
          
          
          <li><a href="./GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="./Hash.html">Hash</a></li>
        
          
          
          <li><a href="./IO.html">IO</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
        
          
          
          <li><a href="./IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="./IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="./IOError.html">IOError</a></li>
        
          
          
          <li><a href="./IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="./Integer.html">Integer</a></li>
        
          
          
          <li><a href="./Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="./Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="./KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="./LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="./LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="./Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="./MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="./Math.html">Math</a></li>
        
          
          
          <li><a href="./Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="./Method.html">Method</a></li>
        
          
          
          <li><a href="./Module.html">Module</a></li>
        
          
          
          <li><a href="./Mutex.html">Mutex</a></li>
        
          
          
          <li><a href="./NameError.html">NameError</a></li>
        
          
          
          <li><a href="./NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="./NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="./NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="./NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="./Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="./Object.html">Object</a></li>
        
          
          
          <li><a href="./ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="./ObjectSpace/WeakMap.html">ObjectSpace::WeakMap</a></li>
        
          
          
          <li><a href="./Proc.html">Proc</a></li>
        
          
          
          <li><a href="./Process.html">Process</a></li>
        
          
          
          <li><a href="./Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="./Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="./Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="./Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="./Process/Waiter.html">Process::Waiter</a></li>
        
          
          
          <li><a href="./Queue.html">Queue</a></li>
        
          
          
          <li><a href="./Random.html">Random</a></li>
        
          
          
          <li><a href="./Range.html">Range</a></li>
        
          
          
          <li><a href="./RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="./Rational.html">Rational</a></li>
        
          
          
          <li><a href="./Rational/compatible.html">Rational::compatible</a></li>
        
          
          
          <li><a href="./Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="./RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="./RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="./RubyVM/Env.html">RubyVM::Env</a></li>
        
          
          
          <li><a href="./RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="./RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="./ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="./SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="./Signal.html">Signal</a></li>
        
          
          
          <li><a href="./SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="./SizedQueue.html">SizedQueue</a></li>
        
          
          
          <li><a href="./StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="./StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="./String.html">String</a></li>
        
          
          
          <li><a href="./Struct.html">Struct</a></li>
        
          
          
          <li><a href="./Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="./SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="./SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="./SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="./SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="./Thread.html">Thread</a></li>
        
          
          
          <li><a href="./Thread/Backtrace/Location.html">Thread::Backtrace::Location</a></li>
        
          
          
          <li><a href="./ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="./ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="./Time.html">Time</a></li>
        
          
          
          <li><a href="./TracePoint.html">TracePoint</a></li>
        
          
          
          <li><a href="./TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="./TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="./UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="./UncaughtThrowError.html">UncaughtThrowError</a></li>
        
          
          
          <li><a href="./ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="./fatal.html">fatal</a></li>
        
          
          
          <li><a href="./unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">Array</h1>

    <div id="description" class="description">
      
<p>Arrays are ordered, integer-indexed collections of any object.</p>

<p><a href="Array.html">Array</a> indexing starts at 0, as in C or Java.  A
negative index is assumed to be relative to the end of the array---that is,
an index of -1 indicates the last element of the array, -2 is the next to
last element in the array, and so on.</p>

<h2 id="class-Array-label-Creating+Arrays">Creating Arrays<span><a href="#class-Array-label-Creating+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>A new array can be created by using the literal constructor
<code>[]</code>.  Arrays can contain different types of objects.  For
example, the array below contains an <a href="Integer.html">Integer</a>, a
<a href="String.html">String</a> and a Float:</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">1</span>, <span class="ruby-string">&quot;two&quot;</span>, <span class="ruby-value">3.0</span>] <span class="ruby-comment">#=&gt; [1, &quot;two&quot;, 3.0]</span>
</pre>

<p>An array can also be created by explicitly calling <a
href="Array.html#method-c-new">::new</a> with zero, one (the initial size
of the <a href="Array.html">Array</a>) or two arguments (the initial size
and a default object).</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>    <span class="ruby-comment">#=&gt; []</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>)       <span class="ruby-comment">#=&gt; [nil, nil, nil]</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>, <span class="ruby-keyword">true</span>) <span class="ruby-comment">#=&gt; [true, true, true]</span>
</pre>

<p>Note that the second argument populates the array with references to the
same object.  Therefore, it is only recommended in cases when you need to
instantiate arrays with natively immutable objects such as Symbols,
numbers, true or false.</p>

<p>To create an array with separate objects a block can be passed instead.
This method is safe to use with mutable objects such as hashes, strings or
other arrays:</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">4</span>) { <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> } <span class="ruby-comment">#=&gt; [{}, {}, {}, {}]</span>
</pre>

<p>This is also a quick way to build up multi-dimensional arrays:</p>

<pre class="ruby"><span class="ruby-identifier">empty_table</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>) { <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>) }
<span class="ruby-comment">#=&gt; [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]</span>
</pre>

<p>An array can also be created by using the Array() method, provided by <a
href="Kernel.html">Kernel</a>, which tries to call <a
href="Array.html#method-i-to_ary">to_ary</a>, then <a
href="Array.html#method-i-to_a">to_a</a> on its argument.</p>

<pre class="ruby"><span class="ruby-constant">Array</span>({:<span class="ruby-identifier">a</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;a&quot;</span>, :<span class="ruby-identifier">b</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;b&quot;</span>}) <span class="ruby-comment">#=&gt; [[:a, &quot;a&quot;], [:b, &quot;b&quot;]]</span>
</pre>

<h2 id="class-Array-label-Example+Usage">Example Usage<span><a href="#class-Array-label-Example+Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In addition to the methods it mixes in through the <a
href="Enumerable.html">Enumerable</a> module, the <a
href="Array.html">Array</a> class has proprietary methods for accessing,
searching and otherwise manipulating arrays.</p>

<p>Some of the more common ones are illustrated below.</p>

<h2 id="class-Array-label-Accessing+Elements">Accessing Elements<span><a href="#class-Array-label-Accessing+Elements">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Elements in an array can be retrieved using the <a
href="Array.html#method-i-5B-5D">#[]</a> method.  It can take a single
integer argument (a numeric index), a pair of arguments (start and length)
or a range. Negative indices start counting from the end, with -1 being the
last element.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>[<span class="ruby-value">2</span>]    <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">100</span>]  <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">-3</span>]   <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>] <span class="ruby-comment">#=&gt; [3, 4, 5]</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>] <span class="ruby-comment">#=&gt; [2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>] <span class="ruby-comment">#=&gt; [2, 3, 4]</span>
</pre>

<p>Another way to access a particular array element is by using the <a
href="Array.html#method-i-at">at</a> method</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>) <span class="ruby-comment">#=&gt; 1</span>
</pre>

<p>The <a href="Array.html#method-i-slice">slice</a> method works in an
identical manner to <a href="Array.html#method-i-5B-5D">#[]</a>.</p>

<p>To raise an error for indices outside of the array bounds or else to
provide a default value when that happens, you can use <a
href="Array.html#method-i-fetch">fetch</a>.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-string">'a'</span>, <span class="ruby-string">'b'</span>, <span class="ruby-string">'c'</span>, <span class="ruby-string">'d'</span>, <span class="ruby-string">'e'</span>, <span class="ruby-string">'f'</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">100</span>) <span class="ruby-comment">#=&gt; IndexError: index 100 outside of array bounds: -6...6</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">100</span>, <span class="ruby-string">&quot;oops&quot;</span>) <span class="ruby-comment">#=&gt; &quot;oops&quot;</span>
</pre>

<p>The special methods <a href="Array.html#method-i-first">first</a> and <a
href="Array.html#method-i-last">last</a> will return the first and last
elements of an array, respectively.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">first</span> <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">last</span>  <span class="ruby-comment">#=&gt; 6</span>
</pre>

<p>To return the first <code>n</code> elements of an array, use <a
href="Array.html#method-i-take">take</a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

<p><a href="Array.html#method-i-drop">drop</a> does the opposite of <a
href="Array.html#method-i-take">take</a>, by returning the elements after
<code>n</code> elements have been dropped:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">3</span>) <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
</pre>

<h2 id="class-Array-label-Obtaining+Information+about+an+Array">Obtaining Information about an <a href="Array.html">Array</a><span><a href="#class-Array-label-Obtaining+Information+about+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Arrays keep track of their own length at all times.  To query an array
about the number of elements it contains, use <a
href="Array.html#method-i-length">length</a>, <a
href="Array.html#method-i-count">count</a> or <a
href="Array.html#method-i-size">size</a>.</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span> = [<span class="ruby-string">'Chrome'</span>, <span class="ruby-string">'Firefox'</span>, <span class="ruby-string">'Safari'</span>, <span class="ruby-string">'Opera'</span>, <span class="ruby-string">'IE'</span>]
<span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">length</span> <span class="ruby-comment">#=&gt; 5</span>
<span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">count</span> <span class="ruby-comment">#=&gt; 5</span>
</pre>

<p>To check whether an array contains any elements at all</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>To check whether a particular item is included in the array</p>

<pre class="ruby"><span class="ruby-identifier">browsers</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">'Konqueror'</span>) <span class="ruby-comment">#=&gt; false</span>
</pre>

<h2 id="class-Array-label-Adding+Items+to+Arrays">Adding Items to Arrays<span><a href="#class-Array-label-Adding+Items+to+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Items can be added to the end of an array by using either <a
href="Array.html#method-i-push">push</a> or <a
href="Array.html#method-i-3C-3C"><<</a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">push</span>(<span class="ruby-value">5</span>) <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">6</span>    <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6]</span>
</pre>

<p><a href="Array.html#method-i-unshift">unshift</a> will add a new item to
the beginning of an array.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">0</span>) <span class="ruby-comment">#=&gt; [0, 1, 2, 3, 4, 5, 6]</span>
</pre>

<p>With <a href="Array.html#method-i-insert">insert</a> you can add a new
element to an array at any position.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">3</span>, <span class="ruby-string">'apple'</span>)  <span class="ruby-comment">#=&gt; [0, 1, 2, 'apple', 3, 4, 5, 6]</span>
</pre>

<p>Using the <a href="Array.html#method-i-insert">insert</a> method, you can
also insert multiple values at once:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">3</span>, <span class="ruby-string">'orange'</span>, <span class="ruby-string">'pear'</span>, <span class="ruby-string">'grapefruit'</span>)
<span class="ruby-comment">#=&gt; [0, 1, 2, &quot;orange&quot;, &quot;pear&quot;, &quot;grapefruit&quot;, &quot;apple&quot;, 3, 4, 5, 6]</span>
</pre>

<h2 id="class-Array-label-Removing+Items+from+an+Array">Removing Items from an <a href="Array.html">Array</a><span><a href="#class-Array-label-Removing+Items+from+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The method <a href="Array.html#method-i-pop">pop</a> removes the last
element in an array and returns it:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> =  [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">pop</span> <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
</pre>

<p>To retrieve and at the same time remove the first item, use <a
href="Array.html#method-i-shift">shift</a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">shift</span> <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [2, 3, 4, 5]</span>
</pre>

<p>To delete an element at a particular index:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">2</span>) <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [2, 3, 5]</span>
</pre>

<p>To delete a particular element anywhere in an array, use <a
href="Array.html#method-i-delete">delete</a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">2</span>) <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">arr</span> <span class="ruby-comment">#=&gt; [1,3]</span>
</pre>

<p>A useful method if you need to remove <code>nil</code> values from an array
is <a href="Array.html#method-i-compact">compact</a>:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-string">'foo'</span>, <span class="ruby-value">0</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">'bar'</span>, <span class="ruby-value">7</span>, <span class="ruby-string">'baz'</span>, <span class="ruby-keyword">nil</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">compact</span>  <span class="ruby-comment">#=&gt; ['foo', 0, 'bar', 7, 'baz']</span>
<span class="ruby-identifier">arr</span>          <span class="ruby-comment">#=&gt; ['foo', 0, nil, 'bar', 7, 'baz', nil]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">compact!</span> <span class="ruby-comment">#=&gt; ['foo', 0, 'bar', 7, 'baz']</span>
<span class="ruby-identifier">arr</span>          <span class="ruby-comment">#=&gt; ['foo', 0, 'bar', 7, 'baz']</span>
</pre>

<p>Another common need is to remove duplicate elements from an array.</p>

<p>It has the non-destructive <a href="Array.html#method-i-uniq">uniq</a>, and
destructive method <a href="Array.html#method-i-uniq-21">uniq!</a></p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">2</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">556</span>, <span class="ruby-value">6</span>, <span class="ruby-value">6</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">0</span>, <span class="ruby-value">123</span>, <span class="ruby-value">556</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">uniq</span> <span class="ruby-comment">#=&gt; [2, 5, 6, 556, 8, 9, 0, 123]</span>
</pre>

<h2 id="class-Array-label-Iterating+over+Arrays">Iterating over Arrays<span><a href="#class-Array-label-Iterating+over+Arrays">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Like all classes that include the <a href="Enumerable.html">Enumerable</a>
module, <a href="Array.html">Array</a> has an each method, which defines
what elements should be iterated over and how.  In case of Array’s <a
href="Array.html#method-i-each">each</a>, all elements in the <a
href="Array.html">Array</a> instance are yielded to the supplied block in
sequence.</p>

<p>Note that this operation leaves the array unchanged.</p>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">-=</span> <span class="ruby-value">10</span>, <span class="ruby-string">&quot; &quot;</span> }
<span class="ruby-comment"># prints: -9 -8 -7 -6 -5</span>
<span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
</pre>

<p>Another sometimes useful iterator is <a
href="Array.html#method-i-reverse_each">reverse_each</a> which will iterate
over the elements in the array in reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">words</span> = <span class="ruby-node">%w[first second third fourth fifth sixth]</span>
<span class="ruby-identifier">str</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">words</span>.<span class="ruby-identifier">reverse_each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">str</span> <span class="ruby-operator">+=</span> <span class="ruby-node">&quot;#{word} &quot;</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">str</span> <span class="ruby-comment">#=&gt; &quot;sixth fifth fourth third second first &quot;</span>
</pre>

<p>The <a href="Array.html#method-i-map">map</a> method can be used to create
a new array based on the original array, but with the values modified by
the supplied block:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-value">2</span><span class="ruby-operator">*</span><span class="ruby-identifier">a</span> }   <span class="ruby-comment">#=&gt; [2, 4, 6, 8, 10]</span>
<span class="ruby-identifier">arr</span>                   <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> } <span class="ruby-comment">#=&gt; [1, 4, 9, 16, 25]</span>
<span class="ruby-identifier">arr</span>                   <span class="ruby-comment">#=&gt; [1, 4, 9, 16, 25]</span>
</pre>

<h2 id="class-Array-label-Selecting+Items+from+an+Array">Selecting Items from an <a href="Array.html">Array</a><span><a href="#class-Array-label-Selecting+Items+from+an+Array">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Elements can be selected from an array according to criteria defined in a
block.  The selection can happen in a destructive or a non-destructive
manner.  While the destructive operations will modify the array they were
called on, the non-destructive methods usually return a new array with the
selected elements, but leave the original array unchanged.</p>

<h3 id="class-Array-label-Non-destructive+Selection">Non-destructive Selection<span><a href="#class-Array-label-Non-destructive+Selection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span> }     <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }     <span class="ruby-comment">#=&gt; [3, 4, 5, 6]</span>
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">drop_while</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>                          <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6]</span>
</pre>

<h3 id="class-Array-label-Destructive+Selection">Destructive Selection<span><a href="#class-Array-label-Destructive+Selection">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Array.html#method-i-select-21">select!</a> and <a
href="Array.html#method-i-reject-21">reject!</a> are the corresponding
destructive methods to <a href="Array.html#method-i-select">select</a> and
<a href="Array.html#method-i-reject">reject</a></p>

<p>Similar to <a href="Array.html#method-i-select">select</a> vs. <a
href="Array.html#method-i-reject">reject</a>, <a
href="Array.html#method-i-delete_if">delete_if</a> and <a
href="Array.html#method-i-keep_if">keep_if</a> have the exact opposite
result when supplied with the same block:</p>

<pre class="ruby"><span class="ruby-identifier">arr</span>.<span class="ruby-identifier">delete_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; [4, 5, 6]</span>
<span class="ruby-identifier">arr</span>                         <span class="ruby-comment">#=&gt; [4, 5, 6]</span>

<span class="ruby-identifier">arr</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
<span class="ruby-identifier">arr</span>.<span class="ruby-identifier">keep_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">arr</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-c-5B-5D"></a>

          
          <div class="method-heading">
            <span class="method-name">[]</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Returns a new array populated with the given objects.</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.[]( <span class="ruby-value">1</span>, <span class="ruby-string">'a'</span>, <span class="ruby-regexp">/^A/</span> ) <span class="ruby-comment"># =&gt; [1, &quot;a&quot;, /^A/]</span>
<span class="ruby-constant">Array</span>[ <span class="ruby-value">1</span>, <span class="ruby-string">'a'</span>, <span class="ruby-regexp">/^A/</span> ]    <span class="ruby-comment"># =&gt; [1, &quot;a&quot;, /^A/]</span>
[ <span class="ruby-value">1</span>, <span class="ruby-string">'a'</span>, <span class="ruby-regexp">/^A/</span> ]         <span class="ruby-comment"># =&gt; [1, &quot;a&quot;, /^A/]</span>
</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE ary = ary_new(klass, argc);
    if (argc &gt; 0 &amp;&amp; argv) {
        ary_memcpy(ary, 0, argc, argv);
        ARY_SET_LEN(ary, argc);
    }

    return ary;
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(size=0, default=nil)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(array)</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(size) {|index| block }</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array.</p>

<p>In the first form, if no arguments are sent, the new array will be empty.
When a <code>size</code> and an optional <code>default</code> are sent, an
array is created with <code>size</code> copies of <code>default</code>. 
Take notice that all elements will reference the same object
<code>default</code>.</p>

<p>The second form creates a copy of the array passed as a parameter (the
array is generated by calling <a
href="Array.html#method-i-to_ary">#to_ary</a> on the parameter).</p>

<pre class="ruby"><span class="ruby-identifier">first_array</span> = [<span class="ruby-string">&quot;Matz&quot;</span>, <span class="ruby-string">&quot;Guido&quot;</span>]

<span class="ruby-identifier">second_array</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">first_array</span>) <span class="ruby-comment">#=&gt; [&quot;Matz&quot;, &quot;Guido&quot;]</span>

<span class="ruby-identifier">first_array</span>.<span class="ruby-identifier">equal?</span> <span class="ruby-identifier">second_array</span>       <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>In the last form, an array of the given size is created.  Each element in
this array is created by passing the element’s index to the given block and
storing the return value.</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>){ <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">**</span> <span class="ruby-value">2</span> }
<span class="ruby-comment"># =&gt; [0, 1, 4]</span>
</pre>

<h2 id="method-c-new-label-Common+gotchas">Common gotchas<span><a href="#method-c-new-label-Common+gotchas">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When sending the second parameter, the same object will be used as the
value for all the array elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>, <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>)
<span class="ruby-comment"># =&gt; [{}, {}]</span>

<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>][<span class="ruby-string">'cat'</span>] = <span class="ruby-string">'feline'</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [{&quot;cat&quot;=&gt;&quot;feline&quot;}, {&quot;cat&quot;=&gt;&quot;feline&quot;}]</span>

<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>][<span class="ruby-string">'cat'</span>] = <span class="ruby-string">'Felix'</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [{&quot;cat&quot;=&gt;&quot;Felix&quot;}, {&quot;cat&quot;=&gt;&quot;Felix&quot;}]</span>
</pre>

<p>Since all the <a href="Array.html">Array</a> elements store the same hash,
changes to one of them will affect them all.</p>

<p>If multiple copies are what you want, you should use the block version
which uses the result of that block each time an element of the array needs
to be initialized:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>) { <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> }
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>][<span class="ruby-string">'cat'</span>] = <span class="ruby-string">'feline'</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [{&quot;cat&quot;=&gt;&quot;feline&quot;}, {}]</span>
</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_initialize(int argc, VALUE *argv, VALUE ary)
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (argc == 0) {
        if (ARY_OWNS_HEAP_P(ary) &amp;&amp; RARRAY_CONST_PTR(ary) != 0) {
            ruby_sized_xfree((void *)RARRAY_CONST_PTR(ary), ARY_HEAP_SIZE(ary));
        }
        rb_ary_unshare_safe(ary);
        FL_SET_EMBED(ary);
        ARY_SET_EMBED_LEN(ary, 0);
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        return ary;
    }
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val);
    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
        val = rb_check_array_type(size);
        if (!NIL_P(val)) {
            rb_ary_replace(ary, val);
            return ary;
        }
    }

    len = NUM2LONG(size);
    /* NUM2LONG() may call size.to_int, ary can be frozen, modified, etc */
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
        rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    /* recheck after argument conversion */
    rb_ary_modify(ary);
    ary_resize_capa(ary, len);
    if (rb_block_given_p()) {
        long i;

        if (argc == 2) {
            rb_warn(&quot;block supersedes default value argument&quot;);
        }
        for (i=0; i&lt;len; i++) {
            rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
            ARY_SET_LEN(ary, i + 1);
        }
    }
    else {
        ary_memfill(ary, 0, len, val);
        ARY_SET_LEN(ary, len);
    }
    return ary;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
        <div id="try_convert-method" class="method-detail ">
          <a name="method-c-try_convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">try_convert(obj) &rarr; array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Tries to convert <code>obj</code> into an array, using <code>to_ary</code>
method.  Returns the converted array or <code>nil</code> if
<code>obj</code> cannot be converted for any reason. This method can be
used to check if an argument is an array.</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">try_convert</span>([<span class="ruby-value">1</span>])   <span class="ruby-comment">#=&gt; [1]</span>
<span class="ruby-constant">Array</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-string">&quot;1&quot;</span>)   <span class="ruby-comment">#=&gt; nil</span>

<span class="ruby-keyword">if</span> <span class="ruby-identifier">tmp</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-identifier">arg</span>)
  <span class="ruby-comment"># the argument is an array</span>
<span class="ruby-keyword">elsif</span> <span class="ruby-identifier">tmp</span> = <span class="ruby-constant">String</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-identifier">arg</span>)
  <span class="ruby-comment"># the argument is a string</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="try_convert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}
            </pre> 
            </div><!-- try_convert-source -->
            
          </div>

          

          
        </div><!-- try_convert-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="26-method" class="method-detail ">
          <a name="method-i-26"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary & other_ary      &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Set Intersection — Returns a new array containing elements common to the
two arrays, excluding any duplicates. The order is preserved from the
original array.</p>

<p>It compares elements using their <a
href="Array.html#method-i-hash">hash</a> and <a
href="Array.html#method-i-eql-3F">eql?</a> methods for efficiency.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">5</span> ] <span class="ruby-operator">&amp;</span> [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]                 <span class="ruby-comment">#=&gt; [ 1, 3 ]</span>
[ <span class="ruby-string">'a'</span>, <span class="ruby-string">'b'</span>, <span class="ruby-string">'b'</span>, <span class="ruby-string">'z'</span> ] <span class="ruby-operator">&amp;</span> [ <span class="ruby-string">'a'</span>, <span class="ruby-string">'b'</span>, <span class="ruby-string">'c'</span> ]   <span class="ruby-comment">#=&gt; [ 'a', 'b' ]</span>
</pre>

<p>See also <a href="Array.html#method-i-uniq">#uniq</a>.</p>
            

            
            <div class="method-source-code" id="26-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_and(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3, v;
    st_table *table;
    st_data_t vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
    if (RARRAY_LEN(ary2) == 0) return ary3;
    hash = ary_make_hash(ary2);
    table = rb_hash_tbl_raw(hash);

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        v = RARRAY_AREF(ary1, i);
        vv = (st_data_t)v;
        if (st_delete(table, &amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }
    ary_recycle_hash(hash);

    return ary3;
}
            </pre> 
            </div><!-- 26-source -->
            
          </div>

          

          
        </div><!-- 26-method -->
      
        <div id="2A-method" class="method-detail ">
          <a name="method-i-2A"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary * int     &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary * str     &rarr; new_string</span>
            
          </div>
          
          
          <div>
  
            
            <p>Repetition — With a <a href="String.html">String</a> argument, equivalent
to <code>ary.join(str)</code>.</p>

<p>Otherwise, returns a new array built by concatenating the <code>int</code>
copies of <code>self</code>.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ] <span class="ruby-operator">*</span> <span class="ruby-value">3</span>    <span class="ruby-comment">#=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]</span>
[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ] <span class="ruby-operator">*</span> <span class="ruby-string">&quot;,&quot;</span>  <span class="ruby-comment">#=&gt; &quot;1,2,3&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="2A-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_times(VALUE ary, VALUE times)
{
    VALUE ary2, tmp;
    const VALUE *ptr;
    long t, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
        return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) {
        ary2 = ary_new(rb_obj_class(ary), 0);
        goto out;
    }
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY_LEN(ary)) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    len *= RARRAY_LEN(ary);

    ary2 = ary_new(rb_obj_class(ary), len);
    ARY_SET_LEN(ary2, len);

    ptr = RARRAY_CONST_PTR(ary);
    t = RARRAY_LEN(ary);
    if (0 &lt; t) {
        ary_memcpy(ary2, 0, t, ptr);
        while (t &lt;= len/2) {
            ary_memcpy(ary2, t, t, RARRAY_CONST_PTR(ary2));
            t *= 2;
        }
        if (t &lt; len) {
            ary_memcpy(ary2, t, len-t, RARRAY_CONST_PTR(ary2));
        }
    }
  out:
    OBJ_INFECT(ary2, ary);

    return ary2;
}
            </pre> 
            </div><!-- 2A-source -->
            
          </div>

          

          
        </div><!-- 2A-method -->
      
        <div id="2B-method" class="method-detail ">
          <a name="method-i-2B"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary + other_ary   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Concatenation — Returns a new array built by concatenating the two arrays
together to produce a third array.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ] <span class="ruby-operator">+</span> [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ]    <span class="ruby-comment">#=&gt; [ 1, 2, 3, 4, 5 ]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">a</span> <span class="ruby-operator">+</span> [ <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span>, <span class="ruby-string">&quot;f&quot;</span> ]
<span class="ruby-identifier">c</span>                         <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]</span>
<span class="ruby-identifier">a</span>                         <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>
</pre>

<p>Note that</p>

<pre class="ruby"><span class="ruby-identifier">x</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">y</span>
</pre>

<p>is the same as</p>

<pre class="ruby"><span class="ruby-identifier">x</span> = <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">y</span>
</pre>

<p>This means that it produces a new array. As a consequence, repeated use of
<code>+=</code> on arrays can be quite inefficient.</p>

<p>See also <a href="Array.html#method-i-concat">#concat</a>.</p>
            

            
            <div class="method-source-code" id="2B-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_plus(VALUE x, VALUE y)
{
    VALUE z;
    long len, xlen, ylen;

    y = to_ary(y);
    xlen = RARRAY_LEN(x);
    ylen = RARRAY_LEN(y);
    len = xlen + ylen;
    z = rb_ary_new2(len);

    ary_memcpy(z, 0, xlen, RARRAY_CONST_PTR(x));
    ary_memcpy(z, xlen, ylen, RARRAY_CONST_PTR(y));
    ARY_SET_LEN(z, len);
    return z;
}
            </pre> 
            </div><!-- 2B-source -->
            
          </div>

          

          
        </div><!-- 2B-method -->
      
        <div id="2D-method" class="method-detail ">
          <a name="method-i-2D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary - other_ary    &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Array.html">Array</a> Difference</p>

<p>Returns a new array that is a copy of the original array, removing any
items that also appear in <code>other_ary</code>. The order is preserved
from the original array.</p>

<p>It compares elements using their <a
href="Array.html#method-i-hash">hash</a> and <a
href="Array.html#method-i-eql-3F">eql?</a> methods for efficiency.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ] <span class="ruby-operator">-</span> [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">4</span> ]  <span class="ruby-comment">#=&gt;  [ 3, 3, 5 ]</span>
</pre>

<p>If you need set-like behavior, see the library class Set.</p>
            

            
            <div class="method-source-code" id="2D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_diff(VALUE ary1, VALUE ary2)
{
    VALUE ary3;
    VALUE hash;
    long i;

    hash = ary_make_hash(to_ary(ary2));
    ary3 = rb_ary_new();

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        if (st_lookup(rb_hash_tbl_raw(hash), RARRAY_AREF(ary1, i), 0)) continue;
        rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }
    ary_recycle_hash(hash);
    return ary3;
}
            </pre> 
            </div><!-- 2D-source -->
            
          </div>

          

          
        </div><!-- 2D-method -->
      
        <div id="3C-3C-method" class="method-detail ">
          <a name="method-i-3C-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary << obj            &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Append—Pushes the given object on to the end of this array. This expression
returns the array itself, so several appends may be chained together.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;c&quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;d&quot;</span> <span class="ruby-operator">&lt;&lt;</span> [ <span class="ruby-value">3</span>, <span class="ruby-value">4</span> ]
        <span class="ruby-comment">#=&gt;  [ 1, 2, &quot;c&quot;, &quot;d&quot;, [ 3, 4 ] ]</span>
</pre>
            

            
            <div class="method-source-code" id="3C-3C-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_push(VALUE ary, VALUE item)
{
    long idx = RARRAY_LEN(ary);
    VALUE target_ary = ary_ensure_room_for_push(ary, 1);
    RARRAY_PTR_USE(ary, ptr, {
        RB_OBJ_WRITE(target_ary, &amp;ptr[idx], item);
    });
    ARY_SET_LEN(ary, idx + 1);
    return ary;
}
            </pre> 
            </div><!-- 3C-3C-source -->
            
          </div>

          

          
        </div><!-- 3C-3C-method -->
      
        <div id="3C-3D-3E-method" class="method-detail ">
          <a name="method-i-3C-3D-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary <=> other_ary   &rarr;  -1, 0, +1 or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Comparison — Returns an integer (<code>-1</code>, <code>0</code>, or
<code>+1</code>) if this array is less than, equal to, or greater than
<code>other_ary</code>.</p>

<p>Each object in each array is compared (using the &lt;=&gt; operator).</p>

<p>Arrays are compared in an “element-wise” manner; the first element of
<code>ary</code> is compared with the first one of <code>other_ary</code>
using the &lt;=&gt; operator, then each of the second elements, etc… As
soon as the result of any such comparison is non zero (i.e. the two
corresponding elements are not equal), that result is returned for the
whole array comparison.</p>

<p>If all the elements are equal, then the result is based on a comparison of
the array lengths. Thus, two arrays are “equal” according to
Array#&lt;=&gt; if, and only if, they have the same length and the value of
each element is equal to the value of the corresponding element in the
other array.</p>

<p><code>nil</code> is returned if the <code>other_ary</code> is not an array
or if the comparison of two elements returned <code>nil</code>.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]    <span class="ruby-operator">&lt;=&gt;</span> [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]   <span class="ruby-comment">#=&gt; -1</span>
[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ] <span class="ruby-operator">&lt;=&gt;</span> [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ]            <span class="ruby-comment">#=&gt; +1</span>
[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ]             <span class="ruby-operator">&lt;=&gt;</span> [ <span class="ruby-value">1</span>, :<span class="ruby-identifier">two</span> ]         <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="3C-3D-3E-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_cmp(VALUE ary1, VALUE ary2)
{
    long len;
    VALUE v;

    ary2 = rb_check_array_type(ary2);
    if (NIL_P(ary2)) return Qnil;
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive_paired(recursive_cmp, ary1, ary2, ary2);
    if (v != Qundef) return v;
    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}
            </pre> 
            </div><!-- 3C-3D-3E-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-3E-method -->
      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary == other_ary   &rarr;   bool</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Equality — Two arrays are equal if they contain the same number of elements
and if each element is equal to (according to Object#==) the corresponding
element in <code>other_ary</code>.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]    <span class="ruby-operator">==</span> [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-value">7</span> ]     <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-value">7</span> ] <span class="ruby-operator">==</span> [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-value">7</span> ]     <span class="ruby-comment">#=&gt; true</span>
[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-value">7</span> ] <span class="ruby-operator">==</span> [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;f&quot;</span> ]   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_equal(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) {
        if (!rb_respond_to(ary2, idTo_ary)) {
            return Qfalse;
        }
        return rb_equal(ary2, ary1);
    }
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR(ary1) == RARRAY_CONST_PTR(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_equal, ary1, ary2, ary2);
}
            </pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->
      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary[index]                &rarr; obj     or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[start, length]        &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[range]                &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(index)          &rarr; obj     or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(start, length)  &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(range)          &rarr; new_ary or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Element Reference — Returns the element at <code>index</code>, or returns a
subarray starting at the <code>start</code> index and continuing for
<code>length</code> elements, or returns a subarray specified by
<code>range</code> of indices.</p>

<p>Negative indices count backward from the end of the array (-1 is the last
element).  For <code>start</code> and <code>range</code> cases the starting
index is just before an element.  Additionally, an empty array is returned
when the starting index for an element range is at the end of the array.</p>

<p>Returns <code>nil</code> if the index (or starting index) are out of range.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">+</span>  <span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>]    <span class="ruby-comment">#=&gt; &quot;cab&quot;</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>]                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]                <span class="ruby-comment">#=&gt; [ &quot;b&quot;, &quot;c&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>]                <span class="ruby-comment">#=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>]                <span class="ruby-comment">#=&gt; [ &quot;e&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]               <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span>, <span class="ruby-value">3</span>]               <span class="ruby-comment">#=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]</span>
<span class="ruby-comment"># special cases</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span>]                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>, <span class="ruby-value">1</span>]                <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span>, <span class="ruby-value">1</span>]                <span class="ruby-comment">#=&gt; []</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]               <span class="ruby-comment">#=&gt; []</span>
</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_aref(int argc, const VALUE *argv, VALUE ary)
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        if (beg &lt; 0) {
            beg += RARRAY_LEN(ary);
        }
        return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
        rb_scan_args(argc, argv, &quot;11&quot;, NULL, NULL);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
        return rb_ary_entry(ary, FIX2LONG(arg));
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY_LEN(ary), 0)) {
      case Qfalse:
        break;
      case Qnil:
        return Qnil;
      default:
        return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary[index]         = obj                      &rarr;  obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[start, length] = obj or other_ary or nil  &rarr;  obj or other_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[range]         = obj or other_ary or nil  &rarr;  obj or other_ary or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Element Assignment — Sets the element at <code>index</code>, or replaces a
subarray from the <code>start</code> index for <code>length</code>
elements, or replaces a subarray specified by the <code>range</code> of
indices.</p>

<p>If indices are greater than the current capacity of the array, the array
grows automatically.  Elements are inserted into the array at
<code>start</code> if <code>length</code> is zero.</p>

<p>Negative indices will count backward from the end of the array.  For
<code>start</code> and <code>range</code> cases the starting index is just
before an element.</p>

<p>An <a href="IndexError.html">IndexError</a> is raised if a negative index
points past the beginning of the array.</p>

<p>See also <a href="Array.html#method-i-push">#push</a>, and <a
href="Array.html#method-i-unshift">#unshift</a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span>] = <span class="ruby-string">&quot;4&quot;</span>;                 <span class="ruby-comment">#=&gt; [nil, nil, nil, nil, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">3</span>] = [ <span class="ruby-string">'a'</span>, <span class="ruby-string">'b'</span>, <span class="ruby-string">'c'</span> ] <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, nil, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ]          <span class="ruby-comment">#=&gt; [&quot;a&quot;, 1, 2, nil, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>] = <span class="ruby-string">&quot;?&quot;</span>               <span class="ruby-comment">#=&gt; [&quot;?&quot;, 2, nil, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] = <span class="ruby-string">&quot;A&quot;</span>               <span class="ruby-comment">#=&gt; [&quot;A&quot;, &quot;4&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-1</span>]   = <span class="ruby-string">&quot;Z&quot;</span>               <span class="ruby-comment">#=&gt; [&quot;A&quot;, &quot;Z&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] = <span class="ruby-keyword">nil</span>              <span class="ruby-comment">#=&gt; [&quot;A&quot;, nil]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>] = []               <span class="ruby-comment">#=&gt; [&quot;A&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>, <span class="ruby-value">0</span>] = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span> ]          <span class="ruby-comment">#=&gt; [1, 2, &quot;A&quot;]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">3</span>, <span class="ruby-value">0</span>] = <span class="ruby-string">&quot;B&quot;</span>               <span class="ruby-comment">#=&gt; [1, 2, &quot;A&quot;, &quot;B&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_aset(int argc, VALUE *argv, VALUE ary)
{
    long offset, beg, len;

    if (argc == 3) {
        rb_ary_modify_check(ary);
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        rb_ary_splice(ary, beg, len, argv[2]);
        return argv[2];
    }
    rb_check_arity(argc, 2, 2);
    rb_ary_modify_check(ary);
    if (FIXNUM_P(argv[0])) {
        offset = FIX2LONG(argv[0]);
        goto fixnum;
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
        /* check if idx is Range */
        rb_ary_splice(ary, beg, len, argv[1]);
        return argv[1];
    }

    offset = NUM2LONG(argv[0]);
fixnum:
    rb_ary_store(ary, offset, argv[1]);
    return argv[1];
}
            </pre> 
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->
      
        <div id="any-3F-method" class="method-detail ">
          <a name="method-i-any-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">any? [{ |obj| block }]   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>See also <a href="Enumerable.html#method-i-any-3F">Enumerable#any?</a></p>
            

            
            <div class="method-source-code" id="any-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_any_p(VALUE ary)
{
    long i, len = RARRAY_LEN(ary);
    const VALUE *ptr = RARRAY_CONST_PTR(ary);

    if (!len) return Qfalse;
    if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) if (RTEST(ptr[i])) return Qtrue;
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    return Qfalse;
}
            </pre> 
            </div><!-- any-3F-source -->
            
          </div>

          

          
        </div><!-- any-3F-method -->
      
        <div id="assoc-method" class="method-detail ">
          <a name="method-i-assoc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">assoc(obj)   &rarr; new_ary  or  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Searches through an array whose elements are also arrays comparing
<code>obj</code> with the first element of each contained array using
<code>obj.==</code>.</p>

<p>Returns the first contained array that matches (that is, the first
associated array), or <code>nil</code> if no match is found.</p>

<p>See also <a href="Array.html#method-i-rassoc">#rassoc</a></p>

<pre class="ruby"><span class="ruby-identifier">s1</span> = [ <span class="ruby-string">&quot;colors&quot;</span>, <span class="ruby-string">&quot;red&quot;</span>, <span class="ruby-string">&quot;blue&quot;</span>, <span class="ruby-string">&quot;green&quot;</span> ]
<span class="ruby-identifier">s2</span> = [ <span class="ruby-string">&quot;letters&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">s3</span> = <span class="ruby-string">&quot;foo&quot;</span>
<span class="ruby-identifier">a</span>  = [ <span class="ruby-identifier">s1</span>, <span class="ruby-identifier">s2</span>, <span class="ruby-identifier">s3</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">assoc</span>(<span class="ruby-string">&quot;letters&quot;</span>)  <span class="ruby-comment">#=&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">assoc</span>(<span class="ruby-string">&quot;foo&quot;</span>)      <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="assoc-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_assoc(VALUE ary, VALUE key)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_AREF(ary, i));
        if (!NIL_P(v) &amp;&amp; RARRAY_LEN(v) &gt; 0 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 0), key))
            return v;
    }
    return Qnil;
}
            </pre> 
            </div><!-- assoc-source -->
            
          </div>

          

          
        </div><!-- assoc-method -->
      
        <div id="at-method" class="method-detail ">
          <a name="method-i-at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">at(index)   &rarr;   obj  or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the element at <code>index</code>. A negative index counts from the
end of <code>self</code>. Returns <code>nil</code> if the index is out of
range. See also <a href="Array.html#method-i-5B-5D">#[]</a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">0</span>)     <span class="ruby-comment">#=&gt; &quot;a&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">-1</span>)    <span class="ruby-comment">#=&gt; &quot;e&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="at-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_at(VALUE ary, VALUE pos)
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}
            </pre> 
            </div><!-- at-source -->
            
          </div>

          

          
        </div><!-- at-method -->
      
        <div id="bsearch-method" class="method-detail ">
          <a name="method-i-bsearch"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">bsearch {|x| block }  &rarr; elem</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>By using binary search, finds a value from this array which meets the given
condition in O(log n) where n is the size of the array.</p>

<p>You can use this method in two use cases: a find-minimum mode and a
find-any mode.  In either case, the elements of the array must be monotone
(or sorted) with respect to the block.</p>

<p>In find-minimum mode (this is a good choice for typical use case), the
block must return true or false, and there must be an index i (0 &lt;= i
&lt;= ary.size) so that:</p>
<ul><li>
<p>the block returns false for any element whose index is less than i, and</p>
</li><li>
<p>the block returns true for any element whose index is greater than or equal
to i.</p>
</li></ul>

<p>This method returns the i-th element.  If i is equal to ary.size, it
returns nil.</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span>   <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span>   <span class="ruby-value">6</span> } <span class="ruby-comment">#=&gt; 7</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span>  <span class="ruby-value">-1</span> } <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">100</span> } <span class="ruby-comment">#=&gt; nil</span>
</pre>

<p>In find-any mode (this behaves like libc’s bsearch(3)), the block must
return a number, and there must be two indices i and j (0 &lt;= i &lt;= j
&lt;= ary.size) so that:</p>
<ul><li>
<p>the block returns a positive number for <a href="k">ary</a> if 0 &lt;= k
&lt; i,</p>
</li><li>
<p>the block returns zero for <a href="k">ary</a> if i &lt;= k &lt; j, and</p>
</li><li>
<p>the block returns a negative number for <a href="k">ary</a> if j &lt;= k
&lt; ary.size.</p>
</li></ul>

<p>Under this condition, this method returns any element whose index is within
i…j.  If i is equal to j (i.e., there is no element that satisfies the
block), this method returns nil.</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">4</span>, <span class="ruby-value">7</span>, <span class="ruby-value">10</span>, <span class="ruby-value">12</span>]
<span class="ruby-comment"># try to find v such that 4 &lt;= v &lt; 8</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-value">1</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">/</span> <span class="ruby-value">4</span> } <span class="ruby-comment">#=&gt; 4 or 7</span>
<span class="ruby-comment"># try to find v such that 8 &lt;= v &lt; 10</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">bsearch</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-value">4</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">/</span> <span class="ruby-value">2</span> } <span class="ruby-comment">#=&gt; nil</span>
</pre>

<p>You must not mix the two modes at a time; the block must always return
either true/false, or always return a number.  It is undefined which value
is actually picked up at each iteration.</p>
            

            
            <div class="method-source-code" id="bsearch-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_bsearch(VALUE ary)
{
    long low = 0, high = RARRAY_LEN(ary), mid;
    int smaller = 0, satisfied = 0;
    VALUE v, val;

    RETURN_ENUMERATOR(ary, 0, 0);
    while (low &lt; high) {
        mid = low + ((high - low) / 2);
        val = rb_ary_entry(ary, mid);
        v = rb_yield(val);
        if (FIXNUM_P(v)) {
            if (FIX2INT(v) == 0) return val;
            smaller = FIX2INT(v) &lt; 0;
        }
        else if (v == Qtrue) {
            satisfied = 1;
            smaller = 1;
        }
        else if (v == Qfalse || v == Qnil) {
            smaller = 0;
        }
        else if (rb_obj_is_kind_of(v, rb_cNumeric)) {
            const VALUE zero = INT2FIX(0);
            switch (rb_cmpint(rb_funcallv(v, id_cmp, 1, &amp;zero), v, INT2FIX(0))) {
                case 0: return val;
                case 1: smaller = 1; break;
                case -1: smaller = 0;
            }
        }
        else {
            rb_raise(rb_eTypeError, &quot;wrong argument type %s&quot;
                &quot; (must be numeric, true, false or nil)&quot;,
                rb_obj_classname(v));
        }
        if (smaller) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    if (low == RARRAY_LEN(ary)) return Qnil;
    if (!satisfied) return Qnil;
    return rb_ary_entry(ary, low);
}
            </pre> 
            </div><!-- bsearch-source -->
            
          </div>

          

          
        </div><!-- bsearch-method -->
      
        <div id="clear-method" class="method-detail ">
          <a name="method-i-clear"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">clear    &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes all elements from <code>self</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">clear</span>    <span class="ruby-comment">#=&gt; [ ]</span>
</pre>
            

            
            <div class="method-source-code" id="clear-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_clear(VALUE ary)
{
    rb_ary_modify_check(ary);
    ARY_SET_LEN(ary, 0);
    if (ARY_SHARED_P(ary)) {
        if (!ARY_EMBED_P(ary)) {
            rb_ary_unshare(ary);
            FL_SET_EMBED(ary);
        }
    }
    else if (ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
        ary_resize_capa(ary, ARY_DEFAULT_SIZE * 2);
    }
    return ary;
}
            </pre> 
            </div><!-- clear-source -->
            
          </div>

          

          
        </div><!-- clear-method -->
      
        <div id="collect-method" class="method-detail ">
          <a name="method-i-collect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect { |item| block }  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect                   &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the given block once for each element of <code>self</code>.</p>

<p>Creates a new array containing the values returned by the block.</p>

<p>See also <a href="Enumerable.html#method-i-collect">Enumerable#collect</a>.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;!&quot;</span> }        <span class="ruby-comment">#=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span>.<span class="ruby-identifier">with_index</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">i</span> } <span class="ruby-comment">#=&gt; [&quot;&quot;, &quot;b&quot;, &quot;cc&quot;, &quot;ddd&quot;]</span>
<span class="ruby-identifier">a</span>                                <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="collect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_push(collect, rb_yield(RARRAY_AREF(ary, i)));
    }
    return collect;
}
            </pre> 
            </div><!-- collect-source -->
            
          </div>

          

          
        </div><!-- collect-method -->
      
        <div id="collect-21-method" class="method-detail ">
          <a name="method-i-collect-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect! {|item| block }   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect!                   &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the given block once for each element of <code>self</code>,
replacing the element with the value returned by the block.</p>

<p>See also <a href="Enumerable.html#method-i-collect">Enumerable#collect</a>.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;!&quot;</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment">#=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">collect!</span>.<span class="ruby-identifier">with_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">i</span>] }
<span class="ruby-identifier">a</span> <span class="ruby-comment">#=&gt;  [&quot;&quot;, &quot;b&quot;, &quot;c!&quot;, &quot;d!&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="collect-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY_AREF(ary, i)));
    }
    return ary;
}
            </pre> 
            </div><!-- collect-21-source -->
            
          </div>

          

          
        </div><!-- collect-21-method -->
      
        <div id="combination-method" class="method-detail ">
          <a name="method-i-combination"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">combination(n) { |c| block }    &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">combination(n)                  &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>When invoked with a block, yields all combinations of length <code>n</code>
of elements from the array and then returns the array itself.</p>

<p>The implementation makes no guarantees about the order in which the
combinations are yielded.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">1</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1],[2],[3],[4]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">2</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">3</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">4</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,2,3,4]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[]] # one combination of length 0</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">combination</span>(<span class="ruby-value">5</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; []   # no combinations of length 5</span>
</pre>
            

            
            <div class="method-source-code" id="combination-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_combination(VALUE ary, VALUE num)
{
    long i, n, len;

    n = NUM2LONG(num);
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_combination_size);
    len = RARRAY_LEN(ary);
    if (n &lt; 0 || len &lt; n) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; len; i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        volatile VALUE t0;
        long *stack = ALLOCV_N(long, t0, n+1);

        RBASIC_CLEAR_CLASS(ary0);
        combinate0(len, n, stack, ary0);
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}
            </pre> 
            </div><!-- combination-source -->
            
          </div>

          

          
        </div><!-- combination-method -->
      
        <div id="compact-method" class="method-detail ">
          <a name="method-i-compact"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compact     &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copy of <code>self</code> with all <code>nil</code> elements
removed.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-keyword">nil</span> ].<span class="ruby-identifier">compact</span>
                  <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>
</pre>
            

            
            <div class="method-source-code" id="compact-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_compact(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- compact-source -->
            
          </div>

          

          
        </div><!-- compact-method -->
      
        <div id="compact-21-method" class="method-detail ">
          <a name="method-i-compact-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compact!    &rarr; ary  or  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes <code>nil</code> elements from the array.</p>

<p>Returns <code>nil</code> if no changes were made, otherwise returns the
array.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">compact!</span> <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span>
[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">compact!</span>           <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="compact-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_compact_bang(VALUE ary)
{
    VALUE *p, *t, *end;
    long n;

    rb_ary_modify(ary);
    p = t = (VALUE *)RARRAY_CONST_PTR(ary); /* WB: no new reference */
    end = p + RARRAY_LEN(ary);

    while (t &lt; end) {
        if (NIL_P(*t)) t++;
        else *p++ = *t++;
    }
    n = p - RARRAY_CONST_PTR(ary);
    if (RARRAY_LEN(ary) == n) {
        return Qnil;
    }
    ary_resize_smaller(ary, n);

    return ary;
}
            </pre> 
            </div><!-- compact-21-source -->
            
          </div>

          

          
        </div><!-- compact-21-method -->
      
        <div id="concat-method" class="method-detail ">
          <a name="method-i-concat"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">concat(other_ary)   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Appends the elements of <code>other_ary</code> to <code>self</code>.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span> ].<span class="ruby-identifier">concat</span>( [<span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>] ) <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">concat</span>( [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ] )
<span class="ruby-identifier">a</span>                                 <span class="ruby-comment">#=&gt; [ 1, 2, 3, 4, 5 ]</span>
</pre>

<p>See also Array#+.</p>
            

            
            <div class="method-source-code" id="concat-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_concat(VALUE x, VALUE y)
{
    rb_ary_modify_check(x);
    y = to_ary(y);
    if (RARRAY_LEN(y) &gt; 0) {
        rb_ary_splice(x, RARRAY_LEN(x), 0, y);
    }
    return x;
}
            </pre> 
            </div><!-- concat-source -->
            
          </div>

          

          
        </div><!-- concat-method -->
      
        <div id="count-method" class="method-detail ">
          <a name="method-i-count"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">count                   &rarr; int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count(obj)              &rarr; int</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count { |item| block }  &rarr; int</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of elements.</p>

<p>If an argument is given, counts the number of elements which equal
<code>obj</code> using <code>==</code>.</p>

<p>If a block is given, counts the number of elements for which the block
returns a true value.</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>                  <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>(<span class="ruby-value">2</span>)               <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">%</span><span class="ruby-value">2</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> } <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="count-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_count(int argc, VALUE *argv, VALUE ary)
{
    long i, n = 0;

    if (argc == 0) {
        VALUE v;

        if (!rb_block_given_p())
            return LONG2NUM(RARRAY_LEN(ary));

        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            v = RARRAY_AREF(ary, i);
            if (RTEST(rb_yield(v))) n++;
        }
    }
    else {
        VALUE obj;

        rb_scan_args(argc, argv, &quot;1&quot;, &amp;obj);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            if (rb_equal(RARRAY_AREF(ary, i), obj)) n++;
        }
    }

    return LONG2NUM(n);
}
            </pre> 
            </div><!-- count-source -->
            
          </div>

          

          
        </div><!-- count-method -->
      
        <div id="cycle-method" class="method-detail ">
          <a name="method-i-cycle"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n=nil) { |obj| block }  &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n=nil)                  &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls the given block for each element <code>n</code> times or forever if
<code>nil</code> is given.</p>

<p>Does nothing if a non-positive number is given or the array is empty.</p>

<p>Returns <code>nil</code> if the loop has finished without getting
interrupted.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }     <span class="ruby-comment"># print, a, b, c, a, b, c,.. forever.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span>(<span class="ruby-value">2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c.</span>
</pre>
            

            
            <div class="method-source-code" id="cycle-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_cycle(int argc, VALUE *argv, VALUE ary)
{
    long n, i;
    VALUE nv = Qnil;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_cycle_size);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY_LEN(ary) &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            rb_yield(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}
            </pre> 
            </div><!-- cycle-source -->
            
          </div>

          

          
        </div><!-- cycle-method -->
      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete(obj)            &rarr; item or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">delete(obj) { block }  &rarr; item or result of block</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes all items from <code>self</code> that are equal to
<code>obj</code>.</p>

<p>Returns the last deleted item, or <code>nil</code> if no matching item is
found.</p>

<p>If the optional code block is given, the result of the block is returned if
the item is not found.  (To remove <code>nil</code> elements and get an
informative return value, use <a
href="Array.html#method-i-compact-21">#compact!</a>)</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&quot;b&quot;</span>)                   <span class="ruby-comment">#=&gt; &quot;b&quot;</span>
<span class="ruby-identifier">a</span>                               <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&quot;z&quot;</span>)                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&quot;z&quot;</span>) { <span class="ruby-string">&quot;not found&quot;</span> }   <span class="ruby-comment">#=&gt; &quot;not found&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="delete-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_delete(VALUE ary, VALUE item)
{
    VALUE v = item;
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE e = RARRAY_AREF(ary, i1);

        if (rb_equal(e, item)) {
            v = e;
            continue;
        }
        if (i1 != i2) {
            rb_ary_store(ary, i2, e);
        }
        i2++;
    }
    if (RARRAY_LEN(ary) == i2) {
        if (rb_block_given_p()) {
            return rb_yield(item);
        }
        return Qnil;
    }

    ary_resize_smaller(ary, i2);

    return v;
}
            </pre> 
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->
      
        <div id="delete_at-method" class="method-detail ">
          <a name="method-i-delete_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete_at(index)  &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes the element at the specified <code>index</code>, returning that
element, or <code>nil</code> if the <code>index</code> is out of range.</p>

<p>See also <a href="Array.html#method-i-slice-21">#slice!</a></p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&quot;ant&quot;</span>, <span class="ruby-string">&quot;bat&quot;</span>, <span class="ruby-string">&quot;cat&quot;</span>, <span class="ruby-string">&quot;dog&quot;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">2</span>)    <span class="ruby-comment">#=&gt; &quot;cat&quot;</span>
<span class="ruby-identifier">a</span>                 <span class="ruby-comment">#=&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">99</span>)   <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="delete_at-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_delete_at_m(VALUE ary, VALUE pos)
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}
            </pre> 
            </div><!-- delete_at-source -->
            
          </div>

          

          
        </div><!-- delete_at-method -->
      
        <div id="delete_if-method" class="method-detail ">
          <a name="method-i-delete_if"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete_if { |item| block }  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">delete_if                   &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes every element of <code>self</code> for which block evaluates to
<code>true</code>.</p>

<p>The array is changed instantly every time the block is called, not after
the iteration is over.</p>

<p>See also <a href="Array.html#method-i-reject-21">#reject!</a></p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">scores</span> = [ <span class="ruby-value">97</span>, <span class="ruby-value">42</span>, <span class="ruby-value">75</span> ]
<span class="ruby-identifier">scores</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">score</span><span class="ruby-operator">|</span> <span class="ruby-identifier">score</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">80</span> }   <span class="ruby-comment">#=&gt; [97]</span>
</pre>
            

            
            <div class="method-source-code" id="delete_if-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_delete_if(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    ary_reject_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- delete_if-source -->
            
          </div>

          

          
        </div><!-- delete_if-method -->
      
        <div id="drop-method" class="method-detail ">
          <a name="method-i-drop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop(n)               &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Drops first <code>n</code> elements from <code>ary</code> and returns the
rest of the elements in an array.</p>

<p>If a negative number is given, raises an <a
href="ArgumentError.html">ArgumentError</a>.</p>

<p>See also <a href="Array.html#method-i-take">#take</a></p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment">#=&gt; [4, 5, 0]</span>
</pre>
            

            
            <div class="method-source-code" id="drop-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_drop(VALUE ary, VALUE n)
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_subseq(ary, pos, RARRAY_LEN(ary));
    if (result == Qnil) result = rb_ary_new();
    return result;
}
            </pre> 
            </div><!-- drop-source -->
            
          </div>

          

          
        </div><!-- drop-method -->
      
        <div id="drop_while-method" class="method-detail ">
          <a name="method-i-drop_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop_while { |arr| block }   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">drop_while                  &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Drops elements up to, but not including, the first element for which the
block returns <code>nil</code> or <code>false</code> and returns an array
containing the remaining elements.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<p>See also <a href="Array.html#method-i-take_while">#take_while</a></p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; [3, 4, 5, 0]</span>
</pre>
            

            
            <div class="method-source-code" id="drop_while-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_drop_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}
            </pre> 
            </div><!-- drop_while-source -->
            
          </div>

          

          
        </div><!-- drop_while-method -->
      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each { |item| block }  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each                   &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls the given block once for each element in <code>self</code>, passing
that element as a parameter.</p>

<p>An <a href="Enumerator.html">Enumerator</a> is returned if no block is
given.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; -- &quot;</span> }
</pre>

<p>produces:</p>

<pre>a -- b -- c --</pre>
            

            
            <div class="method-source-code" id="each-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_each(VALUE array)
{
    long i;
    volatile VALUE ary = array;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(RARRAY_AREF(ary, i));
    }
    return ary;
}
            </pre> 
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->
      
        <div id="each_index-method" class="method-detail ">
          <a name="method-i-each_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_index { |index| block }  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_index                    &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Same as <a href="Array.html#method-i-each">#each</a>, but passes the
<code>index</code> of the element instead of the element itself.</p>

<p>An <a href="Enumerator.html">Enumerator</a> is returned if no block is
given.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">each_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; -- &quot;</span> }
</pre>

<p>produces:</p>

<pre>0 -- 1 -- 2 --</pre>
            

            
            <div class="method-source-code" id="each_index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_each_index(VALUE ary)
{
    long i;
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(LONG2NUM(i));
    }
    return ary;
}
            </pre> 
            </div><!-- each_index-source -->
            
          </div>

          

          
        </div><!-- each_index-method -->
      
        <div id="empty-3F-method" class="method-detail ">
          <a name="method-i-empty-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">empty?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <code>self</code> contains no elements.</p>

<pre class="ruby">[].<span class="ruby-identifier">empty?</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="empty-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_empty_p(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0)
        return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- empty-3F-source -->
            
          </div>

          

          
        </div><!-- empty-3F-method -->
      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eql?(other)  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <code>self</code> and <code>other</code> are
the same object, or are both arrays with the same content (according to <a
href="Object.html#method-i-eql-3F">Object#eql?</a>).</p>
            

            
            <div class="method-source-code" id="eql-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_eql(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) return Qfalse;
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR(ary1) == RARRAY_CONST_PTR(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_eql, ary1, ary2, ary2);
}
            </pre> 
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->
      
        <div id="fetch-method" class="method-detail ">
          <a name="method-i-fetch"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index)                    &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index, default)           &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index) { |index| block }  &rarr; obj</span>
            
          </div>
          
          
          <div>
  
            
            <p>Tries to return the element at position <code>index</code>, but throws an
<a href="IndexError.html">IndexError</a> exception if the referenced
<code>index</code> lies outside of the array bounds.  This error can be
prevented by supplying a second argument, which will act as a
<code>default</code> value.</p>

<p>Alternatively, if a block is given it will only be executed when an invalid
<code>index</code> is referenced.  Negative values of <code>index</code>
count from the end of the array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">11</span>, <span class="ruby-value">22</span>, <span class="ruby-value">33</span>, <span class="ruby-value">44</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">1</span>)               <span class="ruby-comment">#=&gt; 22</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">-1</span>)              <span class="ruby-comment">#=&gt; 44</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">4</span>, <span class="ruby-string">'cat'</span>)        <span class="ruby-comment">#=&gt; &quot;cat&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">100</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{i} is out of bounds&quot;</span> }
                         <span class="ruby-comment">#=&gt; &quot;100 is out of bounds&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="fetch-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_fetch(int argc, VALUE *argv, VALUE ary)
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn(&quot;block supersedes default value argument&quot;);
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
        idx +=  RARRAY_LEN(ary);
    }
    if (idx &lt; 0 || RARRAY_LEN(ary) &lt;= idx) {
        if (block_given) return rb_yield(pos);
        if (argc == 1) {
            rb_raise(rb_eIndexError, &quot;index %ld outside of array bounds: %ld...%ld&quot;,
                        idx - (idx &lt; 0 ? RARRAY_LEN(ary) : 0), -RARRAY_LEN(ary), RARRAY_LEN(ary));
        }
        return ifnone;
    }
    return RARRAY_AREF(ary, idx);
}
            </pre> 
            </div><!-- fetch-source -->
            
          </div>

          

          
        </div><!-- fetch-method -->
      
        <div id="fill-method" class="method-detail ">
          <a name="method-i-fill"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj)                                 &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj, start [, length])               &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj, range )                         &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill { |index| block }                    &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(start [, length] ) { |index| block } &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(range) { |index| block }             &rarr; ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>The first three forms set the selected elements of <code>self</code> (which
may be the entire array) to <code>obj</code>.</p>

<p>A <code>start</code> of <code>nil</code> is equivalent to zero.</p>

<p>A <code>length</code> of <code>nil</code> is equivalent to the length of
the array.</p>

<p>The last three forms fill the array with the value of the given block,
which is passed the absolute index of each element to be filled.</p>

<p>Negative values of <code>start</code> count from the end of the array,
where <code>-1</code> is the last element.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-string">&quot;x&quot;</span>)              <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-string">&quot;z&quot;</span>, <span class="ruby-value">2</span>, <span class="ruby-value">2</span>)        <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-string">&quot;y&quot;</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>)        <span class="ruby-comment">#=&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> }       <span class="ruby-comment">#=&gt; [0, 1, 4, 9]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">fill</span>(<span class="ruby-value">-2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span><span class="ruby-operator">*</span><span class="ruby-identifier">i</span> } <span class="ruby-comment">#=&gt; [0, 1, 8, 27]</span>
</pre>
            

            
            <div class="method-source-code" id="fill-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_fill(int argc, VALUE *argv, VALUE ary)
{
    VALUE item, arg1, arg2;
    long beg = 0, end = 0, len = 0;
    int block_p = FALSE;

    if (rb_block_given_p()) {
        block_p = TRUE;
        rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg1, &amp;arg2);
        argc += 1;             /* hackish */
    }
    else {
        rb_scan_args(argc, argv, &quot;12&quot;, &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
        beg = 0;
        len = RARRAY_LEN(ary);
        break;
      case 2:
        if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
            break;
        }
        /* fall through */
      case 3:
        beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
        if (beg &lt; 0) {
            beg = RARRAY_LEN(ary) + beg;
            if (beg &lt; 0) beg = 0;
        }
        len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
        break;
    }
    rb_ary_modify(ary);
    if (len &lt; 0) {
        return ary;
    }
    if (beg &gt;= ARY_MAX_SIZE || len &gt; ARY_MAX_SIZE - beg) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    end = beg + len;
    if (RARRAY_LEN(ary) &lt; end) {
        if (end &gt;= ARY_CAPA(ary)) {
            ary_resize_capa(ary, end);
        }
        ary_mem_clear(ary, RARRAY_LEN(ary), end - RARRAY_LEN(ary));
        ARY_SET_LEN(ary, end);
    }

    if (block_p) {
        VALUE v;
        long i;

        for (i=beg; i&lt;end; i++) {
            v = rb_yield(LONG2NUM(i));
            if (i&gt;=RARRAY_LEN(ary)) break;
            ARY_SET(ary, i, v);
        }
    }
    else {
        ary_memfill(ary, beg, len, item);
    }
    return ary;
}
            </pre> 
            </div><!-- fill-source -->
            
          </div>

          

          
        </div><!-- fill-method -->
      
        <div id="find_index-method" class="method-detail ">
          <a name="method-i-find_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">find_index(obj)             &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_index { |item| block } &rarr;  int or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_index                  &rarr;  Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <em>index</em> of the first object in <code>ary</code> such
that the object is <code>==</code> to <code>obj</code>.</p>

<p>If a block is given instead of an argument, returns the <em>index</em> of
the first object for which the block returns <code>true</code>.  Returns
<code>nil</code> if no match is found.</p>

<p>See also <a href="Array.html#method-i-rindex">#rindex</a>.</p>

<p>An <a href="Enumerator.html">Enumerator</a> is returned if neither a block
nor argument is given.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;b&quot;</span>)              <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;z&quot;</span>)              <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;b&quot;</span> }  <span class="ruby-comment">#=&gt; 1</span>
</pre>
            

            
            <div class="method-source-code" id="find_index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_index(int argc, VALUE *argv, VALUE ary)
{
    const VALUE *ptr;
    VALUE val;
    long i, len;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
                return LONG2NUM(i);
            }
        }
        return Qnil;
    }
    rb_check_arity(argc, 0, 1);
    val = argv[0];
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    len = RARRAY_LEN(ary);
    ptr = RARRAY_CONST_PTR(ary);
    for (i=0; i&lt;len; i++) {
        VALUE e = ptr[i];
        switch (rb_equal_opt(e, val)) {
          case Qundef:
            if (!rb_equal(e, val)) break;
          case Qtrue:
            return LONG2NUM(i);
          case Qfalse:
            continue;
        }
        len = RARRAY_LEN(ary);
        ptr = RARRAY_CONST_PTR(ary);
    }
    return Qnil;
}
            </pre> 
            </div><!-- find_index-source -->
            
          </div>

          

          
        </div><!-- find_index-method -->
      
        <div id="first-method" class="method-detail ">
          <a name="method-i-first"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">first     &rarr;   obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">first(n)  &rarr;   new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the first element, or the first <code>n</code> elements, of the
array. If the array is empty, the first form returns <code>nil</code>, and
the second form returns an empty array. See also <a
href="Array.html#method-i-last">#last</a> for the opposite effect.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;q&quot;</span>, <span class="ruby-string">&quot;r&quot;</span>, <span class="ruby-string">&quot;s&quot;</span>, <span class="ruby-string">&quot;t&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>     <span class="ruby-comment">#=&gt; &quot;q&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [&quot;q&quot;, &quot;r&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="first-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_first(int argc, VALUE *argv, VALUE ary)
{
    if (argc == 0) {
        if (RARRAY_LEN(ary) == 0) return Qnil;
        return RARRAY_AREF(ary, 0);
    }
    else {
        return ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    }
}
            </pre> 
            </div><!-- first-source -->
            
          </div>

          

          
        </div><!-- first-method -->
      
        <div id="flatten-method" class="method-detail ">
          <a name="method-i-flatten"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flatten &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flatten(level) &rarr; new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array that is a one-dimensional flattening of
<code>self</code> (recursively).</p>

<p>That is, for every element that is an array, extract its elements into the
new array.</p>

<p>The optional <code>level</code> argument determines the level of recursion
to flatten.</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]           <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">t</span> = [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, [<span class="ruby-value">7</span>, <span class="ruby-value">8</span>] ]   <span class="ruby-comment">#=&gt; [4, 5, 6, [7, 8]]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-identifier">s</span>, <span class="ruby-identifier">t</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span> ]       <span class="ruby-comment">#=&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>                 <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, [<span class="ruby-value">3</span>, [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>] ] ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">1</span>)              <span class="ruby-comment">#=&gt; [1, 2, 3, [4, 5]]</span>
</pre>
            

            
            <div class="method-source-code" id="flatten-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_flatten(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return ary_make_shared_copy(ary);

    result = flatten(ary, level, &amp;mod);
    OBJ_INFECT(result, ary);

    return result;
}
            </pre> 
            </div><!-- flatten-source -->
            
          </div>

          

          
        </div><!-- flatten-method -->
      
        <div id="flatten-21-method" class="method-detail ">
          <a name="method-i-flatten-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flatten!        &rarr; ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flatten!(level) &rarr; ary or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Flattens <code>self</code> in place.</p>

<p>Returns <code>nil</code> if no modifications were made (i.e., the array
contains no subarrays.)</p>

<p>The optional <code>level</code> argument determines the level of recursion
to flatten.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, [<span class="ruby-value">3</span>, [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>] ] ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>   <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>            <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
<span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, [<span class="ruby-value">3</span>, [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>] ] ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">flatten!</span>(<span class="ruby-value">1</span>) <span class="ruby-comment">#=&gt; [1, 2, 3, [4, 5]]</span>
</pre>
            

            
            <div class="method-source-code" id="flatten-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_flatten_bang(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    rb_ary_modify_check(ary);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return Qnil;

    result = flatten(ary, level, &amp;mod);
    if (mod == 0) {
        ary_discard(result);
        return Qnil;
    }
    if (!(mod = ARY_EMBED_P(result))) rb_obj_freeze(result);
    rb_ary_replace(ary, result);
    if (mod) ARY_SET_EMBED_LEN(result, 0);

    return ary;
}
            </pre> 
            </div><!-- flatten-21-source -->
            
          </div>

          

          
        </div><!-- flatten-21-method -->
      
        <div id="frozen-3F-method" class="method-detail ">
          <a name="method-i-frozen-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">frozen?  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return <code>true</code> if this array is frozen (or temporarily frozen
while being sorted). See also <a
href="Object.html#method-i-frozen-3F">Object#frozen?</a></p>
            

            
            <div class="method-source-code" id="frozen-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_frozen_p(VALUE ary)
{
    if (OBJ_FROZEN(ary)) return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- frozen-3F-source -->
            
          </div>

          

          
        </div><!-- frozen-3F-method -->
      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash   &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Compute a hash-code for this array.</p>

<p>Two arrays with the same content will have the same hash code (and will
compare using <a href="Array.html#method-i-eql-3F">eql?</a>).</p>

<p>See also <a href="Object.html#method-i-hash">Object#hash</a>.</p>
            

            
            <div class="method-source-code" id="hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_hash(VALUE ary)
{
    long i;
    st_index_t h;
    VALUE n;

    h = rb_hash_start(RARRAY_LEN(ary));
    h = rb_hash_uint(h, (st_index_t)rb_ary_hash);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        n = rb_hash(RARRAY_AREF(ary, i));
        h = rb_hash_uint(h, NUM2LONG(n));
    }
    h = rb_hash_end(h);
    return LONG2FIX(h);
}
            </pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->
      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(object)   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the given <code>object</code> is present in
<code>self</code> (that is, if any element <code>==</code>
<code>object</code>), otherwise returns <code>false</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;b&quot;</span>)   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;z&quot;</span>)   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_includes(VALUE ary, VALUE item)
{
    long i;
    VALUE e;

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        switch (rb_equal_opt(e, item)) {
          case Qundef:
            if (rb_equal(e, item)) return Qtrue;
            break;
          case Qtrue:
            return Qtrue;
        }
    }
    return Qfalse;
}
            </pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->
      
        <div id="index-method" class="method-detail ">
          <a name="method-i-index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">index(obj)             &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index { |item| block } &rarr;  int or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index                  &rarr;  Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <em>index</em> of the first object in <code>ary</code> such
that the object is <code>==</code> to <code>obj</code>.</p>

<p>If a block is given instead of an argument, returns the <em>index</em> of
the first object for which the block returns <code>true</code>.  Returns
<code>nil</code> if no match is found.</p>

<p>See also <a href="Array.html#method-i-rindex">#rindex</a>.</p>

<p>An <a href="Enumerator.html">Enumerator</a> is returned if neither a block
nor argument is given.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;b&quot;</span>)              <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;z&quot;</span>)              <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;b&quot;</span> }  <span class="ruby-comment">#=&gt; 1</span>
</pre>
            

            
            <div class="method-source-code" id="index-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_index(int argc, VALUE *argv, VALUE ary)
{
    const VALUE *ptr;
    VALUE val;
    long i, len;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
                return LONG2NUM(i);
            }
        }
        return Qnil;
    }
    rb_check_arity(argc, 0, 1);
    val = argv[0];
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    len = RARRAY_LEN(ary);
    ptr = RARRAY_CONST_PTR(ary);
    for (i=0; i&lt;len; i++) {
        VALUE e = ptr[i];
        switch (rb_equal_opt(e, val)) {
          case Qundef:
            if (!rb_equal(e, val)) break;
          case Qtrue:
            return LONG2NUM(i);
          case Qfalse:
            continue;
        }
        len = RARRAY_LEN(ary);
        ptr = RARRAY_CONST_PTR(ary);
    }
    return Qnil;
}
            </pre> 
            </div><!-- index-source -->
            
          </div>

          

          
        </div><!-- index-method -->
      
        <div id="initialize_copy-method" class="method-detail ">
          <a name="method-i-initialize_copy"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">initialize_copy(other_ary)   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the contents of <code>self</code> with the contents of
<code>other_ary</code>, truncating or expanding if necessary.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">replace</span>([ <span class="ruby-string">&quot;x&quot;</span>, <span class="ruby-string">&quot;y&quot;</span>, <span class="ruby-string">&quot;z&quot;</span> ])   <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
<span class="ruby-identifier">a</span>                              <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="initialize_copy-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    if (RARRAY_LEN(orig) &lt;= RARRAY_EMBED_LEN_MAX) {
        VALUE shared = 0;

        if (ARY_OWNS_HEAP_P(copy)) {
            RARRAY_PTR_USE(copy, ptr, ruby_sized_xfree(ptr, ARY_HEAP_SIZE(copy)));
        }
        else if (ARY_SHARED_P(copy)) {
            shared = ARY_SHARED(copy);
            FL_UNSET_SHARED(copy);
        }
        FL_SET_EMBED(copy);
        ary_memcpy(copy, 0, RARRAY_LEN(orig), RARRAY_CONST_PTR(orig));
        if (shared) {
            rb_ary_decrement_share(shared);
        }
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
    }
    else {
        VALUE shared = ary_make_shared(orig);
        if (ARY_OWNS_HEAP_P(copy)) {
            RARRAY_PTR_USE(copy, ptr, ruby_sized_xfree(ptr, ARY_HEAP_SIZE(copy)));
        }
        else {
            rb_ary_unshare_safe(copy);
        }
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, RARRAY_CONST_PTR(orig));
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
        rb_ary_set_shared(copy, shared);
    }
    return copy;
}
            </pre> 
            </div><!-- initialize_copy-source -->
            
          </div>

          

          
        </div><!-- initialize_copy-method -->
      
        <div id="insert-method" class="method-detail ">
          <a name="method-i-insert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">insert(index, obj...)  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Inserts the given values before the element with the given
<code>index</code>.</p>

<p>Negative indices count backwards from the end of the array, where
<code>-1</code> is the last element. If a negative index is used, the given
values will be inserted after that element, so using an index of
<code>-1</code> will insert the values at the end of the array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w{ a b c d }</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">2</span>, <span class="ruby-value">99</span>)         <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-2</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)   <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="insert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_insert(int argc, VALUE *argv, VALUE ary)
{
    long pos;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    rb_ary_modify_check(ary);
    if (argc == 1) return ary;
    pos = NUM2LONG(argv[0]);
    if (pos == -1) {
        pos = RARRAY_LEN(ary);
    }
    if (pos &lt; 0) {
        pos++;
    }
    rb_ary_splice(ary, pos, 0, rb_ary_new4(argc - 1, argv + 1));
    return ary;
}
            </pre> 
            </div><!-- insert-source -->
            
          </div>

          

          
        </div><!-- insert-method -->
      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect  &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">to_s     &rarr; string</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a string representation of <code>self</code>.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">to_s</span>     <span class="ruby-comment">#=&gt; &quot;[\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;]&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_inspect(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0) return rb_usascii_str_new2(&quot;[]&quot;);
    return rb_exec_recursive(inspect_ary, ary, 0);
}
            </pre> 
            </div><!-- inspect-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Array.html#method-i-to_s">to_s</a>
          </div>
          

          
        </div><!-- inspect-method -->
      
        <div id="join-method" class="method-detail ">
          <a name="method-i-join"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">join(separator=$,)    &rarr; str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a string created by converting each element of the array to a
string, separated by the given <code>separator</code>. If the
<code>separator</code> is <code>nil</code>, it uses current $,. If both the
<code>separator</code> and $, are nil, it uses empty string.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">join</span>        <span class="ruby-comment">#=&gt; &quot;abc&quot;</span>
[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;-&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;a-b-c&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="join-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_join_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE sep;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;sep);
    if (NIL_P(sep)) sep = rb_output_fs;

    return rb_ary_join(ary, sep);
}
            </pre> 
            </div><!-- join-source -->
            
          </div>

          

          
        </div><!-- join-method -->
      
        <div id="keep_if-method" class="method-detail ">
          <a name="method-i-keep_if"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">keep_if { |item| block } &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">keep_if                  &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes every element of <code>self</code> for which the given block
evaluates to <code>false</code>.</p>

<p>See also <a href="Array.html#method-i-select-21">#select!</a></p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w{ a b c d e f }</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">keep_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/[aeiou]/</span> }  <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;e&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="keep_if-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_keep_if(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_select_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- keep_if-source -->
            
          </div>

          

          
        </div><!-- keep_if-method -->
      
        <div id="last-method" class="method-detail ">
          <a name="method-i-last"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">last     &rarr;  obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">last(n)  &rarr;  new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the last element(s) of <code>self</code>. If the array is empty,
the first form returns <code>nil</code>.</p>

<p>See also <a href="Array.html#method-i-first">#first</a> for the opposite
effect.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;w&quot;</span>, <span class="ruby-string">&quot;x&quot;</span>, <span class="ruby-string">&quot;y&quot;</span>, <span class="ruby-string">&quot;z&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span>     <span class="ruby-comment">#=&gt; &quot;z&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">last</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [&quot;y&quot;, &quot;z&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="last-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_last(int argc, const VALUE *argv, VALUE ary)
{
    if (argc == 0) {
        long len = RARRAY_LEN(ary);
        if (len == 0) return Qnil;
        return RARRAY_AREF(ary, len-1);
    }
    else {
        return ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    }
}
            </pre> 
            </div><!-- last-source -->
            
          </div>

          

          
        </div><!-- last-method -->
      
        <div id="length-method" class="method-detail ">
          <a name="method-i-length"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">length &rarr; int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of elements in <code>self</code>. May be zero.</p>

<pre class="ruby">[ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span> ].<span class="ruby-identifier">length</span>   <span class="ruby-comment">#=&gt; 5</span>
[].<span class="ruby-identifier">length</span>                  <span class="ruby-comment">#=&gt; 0</span>
</pre>
            

            
            <div class="method-source-code" id="length-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_length(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    return LONG2NUM(len);
}
            </pre> 
            </div><!-- length-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Array.html#method-i-size">size</a>
          </div>
          

          
        </div><!-- length-method -->
      
        <div id="map-method" class="method-detail ">
          <a name="method-i-map"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">map     { |item| block }  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map                       &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the given block once for each element of <code>self</code>.</p>

<p>Creates a new array containing the values returned by the block.</p>

<p>See also <a href="Enumerable.html#method-i-collect">Enumerable#collect</a>.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;!&quot;</span> }        <span class="ruby-comment">#=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map</span>.<span class="ruby-identifier">with_index</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">i</span> } <span class="ruby-comment">#=&gt; [&quot;&quot;, &quot;b&quot;, &quot;cc&quot;, &quot;ddd&quot;]</span>
<span class="ruby-identifier">a</span>                                <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="map-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_push(collect, rb_yield(RARRAY_AREF(ary, i)));
    }
    return collect;
}
            </pre> 
            </div><!-- map-source -->
            
          </div>

          

          
        </div><!-- map-method -->
      
        <div id="map-21-method" class="method-detail ">
          <a name="method-i-map-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">map!     {|item| block }   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map!                       &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the given block once for each element of <code>self</code>,
replacing the element with the value returned by the block.</p>

<p>See also <a href="Enumerable.html#method-i-collect">Enumerable#collect</a>.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;!&quot;</span> }
<span class="ruby-identifier">a</span> <span class="ruby-comment">#=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">collect!</span>.<span class="ruby-identifier">with_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">i</span>] }
<span class="ruby-identifier">a</span> <span class="ruby-comment">#=&gt;  [&quot;&quot;, &quot;b&quot;, &quot;c!&quot;, &quot;d!&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="map-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY_AREF(ary, i)));
    }
    return ary;
}
            </pre> 
            </div><!-- map-21-source -->
            
          </div>

          

          
        </div><!-- map-21-method -->
      
        <div id="pack-method" class="method-detail ">
          <a name="method-i-pack"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pack ( aTemplateString ) &rarr; aBinaryString</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Packs the contents of <em>arr</em> into a binary sequence according to the
directives in <em>aTemplateString</em> (see the table below) Directives
“A,” “a,” and “Z” may be followed by a count, which gives the width of the
resulting field. The remaining directives also may take a count, indicating
the number of array elements to convert. If the count is an asterisk
(“<code>*</code>”), all remaining array elements will be converted. Any of
the directives “<code>sSiIlL</code>” may be followed by an underscore
(“<code>_</code>”) or exclamation mark (“<code>!</code>”) to use the
underlying platform’s native size for the specified type; otherwise, they
use a platform-independent size. Spaces are ignored in the template string.
See also <code>String#unpack</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">n</span> = [ <span class="ruby-value">65</span>, <span class="ruby-value">66</span>, <span class="ruby-value">67</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;A3A3A3&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;a  b  c  &quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;a3a3a3&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;a\000\000b\000\000c\000\000&quot;</span>
<span class="ruby-identifier">n</span>.<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;ccc&quot;</span>)      <span class="ruby-comment">#=&gt; &quot;ABC&quot;</span>
</pre>

<p>Directives for <code>pack</code>.</p>

<pre>Integer      | Array   |
Directive    | Element | Meaning
---------------------------------------------------------------------------
   C         | Integer | 8-bit unsigned (unsigned char)
   S         | Integer | 16-bit unsigned, native endian (uint16_t)
   L         | Integer | 32-bit unsigned, native endian (uint32_t)
   Q         | Integer | 64-bit unsigned, native endian (uint64_t)
             |         |
   c         | Integer | 8-bit signed (signed char)
   s         | Integer | 16-bit signed, native endian (int16_t)
   l         | Integer | 32-bit signed, native endian (int32_t)
   q         | Integer | 64-bit signed, native endian (int64_t)
             |         |
   S_, S!    | Integer | unsigned short, native endian
   I, I_, I! | Integer | unsigned int, native endian
   L_, L!    | Integer | unsigned long, native endian
   Q_, Q!    | Integer | unsigned long long, native endian (ArgumentError
             |         | if the platform has no long long type.)
             |         | (Q_ and Q! is available since Ruby 2.1.)
             |         |
   s_, s!    | Integer | signed short, native endian
   i, i_, i! | Integer | signed int, native endian
   l_, l!    | Integer | signed long, native endian
   q_, q!    | Integer | signed long long, native endian (ArgumentError
             |         | if the platform has no long long type.)
             |         | (q_ and q! is available since Ruby 2.1.)
             |         |
   S&gt; L&gt; Q&gt;  | Integer | same as the directives without &quot;&gt;&quot; except
   s&gt; l&gt; q&gt;  |         | big endian
   S!&gt; I!&gt;   |         | (available since Ruby 1.9.3)
   L!&gt; Q!&gt;   |         | &quot;S&gt;&quot; is same as &quot;n&quot;
   s!&gt; i!&gt;   |         | &quot;L&gt;&quot; is same as &quot;N&quot;
   l!&gt; q!&gt;   |         |
             |         |
   S&lt; L&lt; Q&lt;  | Integer | same as the directives without &quot;&lt;&quot; except
   s&lt; l&lt; q&lt;  |         | little endian
   S!&lt; I!&lt;   |         | (available since Ruby 1.9.3)
   L!&lt; Q!&lt;   |         | &quot;S&lt;&quot; is same as &quot;v&quot;
   s!&lt; i!&lt;   |         | &quot;L&lt;&quot; is same as &quot;V&quot;
   l!&lt; q!&lt;   |         |
             |         |
   n         | Integer | 16-bit unsigned, network (big-endian) byte order
   N         | Integer | 32-bit unsigned, network (big-endian) byte order
   v         | Integer | 16-bit unsigned, VAX (little-endian) byte order
   V         | Integer | 32-bit unsigned, VAX (little-endian) byte order
             |         |
   U         | Integer | UTF-8 character
   w         | Integer | BER-compressed integer

Float        |         |
Directive    |         | Meaning
---------------------------------------------------------------------------
   D, d      | Float   | double-precision, native format
   F, f      | Float   | single-precision, native format
   E         | Float   | double-precision, little-endian byte order
   e         | Float   | single-precision, little-endian byte order
   G         | Float   | double-precision, network (big-endian) byte order
   g         | Float   | single-precision, network (big-endian) byte order

String       |         |
Directive    |         | Meaning
---------------------------------------------------------------------------
   A         | String  | arbitrary binary string (space padded, count is width)
   a         | String  | arbitrary binary string (null padded, count is width)
   Z         | String  | same as ``a'', except that null is added with *
   B         | String  | bit string (MSB first)
   b         | String  | bit string (LSB first)
   H         | String  | hex string (high nibble first)
   h         | String  | hex string (low nibble first)
   u         | String  | UU-encoded string
   M         | String  | quoted printable, MIME encoding (see RFC2045)
   m         | String  | base64 encoded string (see RFC 2045, count is width)
             |         | (if count is 0, no line feed are added, see RFC 4648)
   P         | String  | pointer to a structure (fixed-length string)
   p         | String  | pointer to a null-terminated string

Misc.        |         |
Directive    |         | Meaning
---------------------------------------------------------------------------
   @         | ---     | moves to absolute position
   X         | ---     | back up a byte
   x         | ---     | null byte</pre>
            

            
            <div class="method-source-code" id="pack-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
pack_pack(VALUE ary, VALUE fmt)
{
    static const char nul10[] = &quot;\0\0\0\0\0\0\0\0\0\0&quot;;
    static const char spc10[] = &quot;          &quot;;
    const char *p, *pend;
    VALUE res, from, associates = 0;
    char type;
    long items, len, idx, plen;
    const char *ptr;
    int enc_info = 1;           /* 0 - BINARY, 1 - US-ASCII, 2 - UTF-8 */
#ifdef NATINT_PACK
    int natint;         /* native integer */
#endif
    int integer_size, bigendian_p;

    StringValue(fmt);
    p = RSTRING_PTR(fmt);
    pend = p + RSTRING_LEN(fmt);
    res = rb_str_buf_new(0);

    items = RARRAY_LEN(ary);
    idx = 0;

#define TOO_FEW (rb_raise(rb_eArgError, toofew), 0)
#define THISFROM (items &gt; 0 ? RARRAY_AREF(ary, idx) : TOO_FEW)
#define NEXTFROM (items-- &gt; 0 ? RARRAY_AREF(ary, idx++) : TOO_FEW)

    while (p &lt; pend) {
        int explicit_endian = 0;
        if (RSTRING_PTR(fmt) + RSTRING_LEN(fmt) != pend) {
            rb_raise(rb_eRuntimeError, &quot;format string modified&quot;);
        }
        type = *p++;           /* get data type */
#ifdef NATINT_PACK
        natint = 0;
#endif

        if (ISSPACE(type)) continue;
        if (type == '#') {
            while ((p &lt; pend) &amp;&amp; (*p != '\n')) {
                p++;
            }
            continue;
        }

        {
          modifiers:
            switch (*p) {
              case '_':
              case '!':
                if (strchr(natstr, type)) {
#ifdef NATINT_PACK
                    natint = 1;
#endif
                    p++;
                }
                else {
                    rb_raise(rb_eArgError, &quot;'%c' allowed only after types %s&quot;, *p, natstr);
                }
                goto modifiers;

              case '&lt;':
              case '&gt;':
                if (!strchr(endstr, type)) {
                    rb_raise(rb_eArgError, &quot;'%c' allowed only after types %s&quot;, *p, endstr);
                }
                if (explicit_endian) {
                    rb_raise(rb_eRangeError, &quot;Can't use both '&lt;' and '&gt;'&quot;);
                }
                explicit_endian = *p++;
                goto modifiers;
            }
        }

        if (*p == '*') {       /* set data length */
            len = strchr(&quot;@Xxu&quot;, type) ? 0
                : strchr(&quot;PMm&quot;, type) ? 1
                : items;
            p++;
        }
        else if (ISDIGIT(*p)) {
            errno = 0;
            len = STRTOUL(p, (char**)&amp;p, 10);
            if (errno) {
                rb_raise(rb_eRangeError, &quot;pack length too big&quot;);
            }
        }
        else {
            len = 1;
        }

        switch (type) {
          case 'U':
            /* if encoding is US-ASCII, upgrade to UTF-8 */
            if (enc_info == 1) enc_info = 2;
            break;
          case 'm': case 'M': case 'u':
            /* keep US-ASCII (do nothing) */
            break;
          default:
            /* fall back to BINARY */
            enc_info = 0;
            break;
        }
        switch (type) {
          case 'A': case 'a': case 'Z':
          case 'B': case 'b':
          case 'H': case 'h':
            from = NEXTFROM;
            if (NIL_P(from)) {
                ptr = &quot;&quot;;
                plen = 0;
            }
            else {
                StringValue(from);
                ptr = RSTRING_PTR(from);
                plen = RSTRING_LEN(from);
                OBJ_INFECT(res, from);
            }

            if (p[-1] == '*')
                len = plen;

            switch (type) {
              case 'a':                /* arbitrary binary string (null padded)  */
              case 'A':         /* arbitrary binary string (ASCII space padded) */
              case 'Z':         /* null terminated string  */
                if (plen &gt;= len) {
                    rb_str_buf_cat(res, ptr, len);
                    if (p[-1] == '*' &amp;&amp; type == 'Z')
                        rb_str_buf_cat(res, nul10, 1);
                }
                else {
                    rb_str_buf_cat(res, ptr, plen);
                    len -= plen;
                    while (len &gt;= 10) {
                        rb_str_buf_cat(res, (type == 'A')?spc10:nul10, 10);
                        len -= 10;
                    }
                    rb_str_buf_cat(res, (type == 'A')?spc10:nul10, len);
                }
                break;

#define castchar(from) (char)((from) &amp; 0xff)

              case 'b':                /* bit string (ascending) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len - plen + 1)/2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (*ptr &amp; 1)
                            byte |= 128;
                        if (i &amp; 7)
                            byte &gt;&gt;= 1;
                        else {
                            char c = castchar(byte);
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 7) {
                        char c;
                        byte &gt;&gt;= 7 - (len &amp; 7);
                        c = castchar(byte);
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'B':                /* bit string (descending) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len - plen + 1)/2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        byte |= *ptr &amp; 1;
                        if (i &amp; 7)
                            byte &lt;&lt;= 1;
                        else {
                            char c = castchar(byte);
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 7) {
                        char c;
                        byte &lt;&lt;= 7 - (len &amp; 7);
                        c = castchar(byte);
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'h':                /* hex string (low nibble first) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len + 1) / 2 - (plen + 1) / 2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (ISALPHA(*ptr))
                            byte |= (((*ptr &amp; 15) + 9) &amp; 15) &lt;&lt; 4;
                        else
                            byte |= (*ptr &amp; 15) &lt;&lt; 4;
                        if (i &amp; 1)
                            byte &gt;&gt;= 4;
                        else {
                            char c = castchar(byte);
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 1) {
                        char c = castchar(byte);
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'H':                /* hex string (high nibble first) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len + 1) / 2 - (plen + 1) / 2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (ISALPHA(*ptr))
                            byte |= ((*ptr &amp; 15) + 9) &amp; 15;
                        else
                            byte |= *ptr &amp; 15;
                        if (i &amp; 1)
                            byte &lt;&lt;= 4;
                        else {
                            char c = castchar(byte);
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 1) {
                        char c = castchar(byte);
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;
            }
            break;

          case 'c':            /* signed char */
          case 'C':            /* unsigned char */
            integer_size = 1;
            bigendian_p = BIGENDIAN_P(); /* not effective */
            goto pack_integer;

          case 's':            /* s for int16_t, s! for signed short */
            integer_size = NATINT_LEN(short, 2);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'S':            /* S for uint16_t, S! for unsigned short */
            integer_size = NATINT_LEN(short, 2);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'i':            /* i and i! for signed int */
            integer_size = (int)sizeof(int);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'I':            /* I and I! for unsigned int */
            integer_size = (int)sizeof(int);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'l':            /* l for int32_t, l! for signed long */
            integer_size = NATINT_LEN(long, 4);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'L':            /* L for uint32_t, L! for unsigned long */
            integer_size = NATINT_LEN(long, 4);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'q':            /* q for int64_t, q! for signed long long */
            integer_size = NATINT_LEN_Q;
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'Q':            /* Q for uint64_t, Q! for unsigned long long */
            integer_size = NATINT_LEN_Q;
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'n':            /* 16 bit (2 bytes) integer (network byte-order)  */
            integer_size = 2;
            bigendian_p = 1;
            goto pack_integer;

          case 'N':            /* 32 bit (4 bytes) integer (network byte-order) */
            integer_size = 4;
            bigendian_p = 1;
            goto pack_integer;

          case 'v':            /* 16 bit (2 bytes) integer (VAX byte-order) */
            integer_size = 2;
            bigendian_p = 0;
            goto pack_integer;

          case 'V':            /* 32 bit (4 bytes) integer (VAX byte-order) */
            integer_size = 4;
            bigendian_p = 0;
            goto pack_integer;

          pack_integer:
            if (explicit_endian) {
                bigendian_p = explicit_endian == '&gt;';
            }
            if (integer_size &gt; MAX_INTEGER_PACK_SIZE)
                rb_bug(&quot;unexpected intger size for pack: %d&quot;, integer_size);
            while (len-- &gt; 0) {
                char intbuf[MAX_INTEGER_PACK_SIZE];

                from = NEXTFROM;
                rb_integer_pack(from, intbuf, integer_size, 1, 0,
                    INTEGER_PACK_2COMP |
                    (bigendian_p ? INTEGER_PACK_BIG_ENDIAN : INTEGER_PACK_LITTLE_ENDIAN));
                rb_str_buf_cat(res, intbuf, integer_size);
            }
            break;

          case 'f':            /* single precision float in native format */
          case 'F':            /* ditto */
            while (len-- &gt; 0) {
                float f;

                from = NEXTFROM;
                f = (float)RFLOAT_VALUE(rb_to_float(from));
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'e':            /* single precision float in VAX byte-order */
            while (len-- &gt; 0) {
                float f;
                FLOAT_CONVWITH(ftmp);

                from = NEXTFROM;
                f = (float)RFLOAT_VALUE(rb_to_float(from));
                f = HTOVF(f,ftmp);
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'E':            /* double precision float in VAX byte-order */
            while (len-- &gt; 0) {
                double d;
                DOUBLE_CONVWITH(dtmp);

                from = NEXTFROM;
                d = RFLOAT_VALUE(rb_to_float(from));
                d = HTOVD(d,dtmp);
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'd':            /* double precision float in native format */
          case 'D':            /* ditto */
            while (len-- &gt; 0) {
                double d;

                from = NEXTFROM;
                d = RFLOAT_VALUE(rb_to_float(from));
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'g':            /* single precision float in network byte-order */
            while (len-- &gt; 0) {
                float f;
                FLOAT_CONVWITH(ftmp);

                from = NEXTFROM;
                f = (float)RFLOAT_VALUE(rb_to_float(from));
                f = HTONF(f,ftmp);
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'G':            /* double precision float in network byte-order */
            while (len-- &gt; 0) {
                double d;
                DOUBLE_CONVWITH(dtmp);

                from = NEXTFROM;
                d = RFLOAT_VALUE(rb_to_float(from));
                d = HTOND(d,dtmp);
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'x':            /* null byte */
          grow:
            while (len &gt;= 10) {
                rb_str_buf_cat(res, nul10, 10);
                len -= 10;
            }
            rb_str_buf_cat(res, nul10, len);
            break;

          case 'X':            /* back up byte */
          shrink:
            plen = RSTRING_LEN(res);
            if (plen &lt; len)
                rb_raise(rb_eArgError, &quot;X outside of string&quot;);
            rb_str_set_len(res, plen - len);
            break;

          case '@':            /* null fill to absolute position */
            len -= RSTRING_LEN(res);
            if (len &gt; 0) goto grow;
            len = -len;
            if (len &gt; 0) goto shrink;
            break;

          case '%':
            rb_raise(rb_eArgError, &quot;%% is not supported&quot;);
            break;

          case 'U':            /* Unicode character */
            while (len-- &gt; 0) {
                SIGNED_VALUE l;
                char buf[8];
                int le;

                from = NEXTFROM;
                from = rb_to_int(from);
                l = NUM2LONG(from);
                if (l &lt; 0) {
                    rb_raise(rb_eRangeError, &quot;pack(U): value out of range&quot;);
                }
                le = rb_uv_to_utf8(buf, l);
                rb_str_buf_cat(res, (char*)buf, le);
            }
            break;

          case 'u':            /* uuencoded string */
          case 'm':            /* base64 encoded string */
            from = NEXTFROM;
            StringValue(from);
            ptr = RSTRING_PTR(from);
            plen = RSTRING_LEN(from);

            if (len == 0 &amp;&amp; type == 'm') {
                encodes(res, ptr, plen, type, 0);
                ptr += plen;
                break;
            }
            if (len &lt;= 2)
                len = 45;
            else if (len &gt; 63 &amp;&amp; type == 'u')
                len = 63;
            else
                len = len / 3 * 3;
            while (plen &gt; 0) {
                long todo;

                if (plen &gt; len)
                    todo = len;
                else
                    todo = plen;
                encodes(res, ptr, todo, type, 1);
                plen -= todo;
                ptr += todo;
            }
            break;

          case 'M':            /* quoted-printable encoded string */
            from = rb_obj_as_string(NEXTFROM);
            if (len &lt;= 1)
                len = 72;
            qpencode(res, from, len);
            break;

          case 'P':            /* pointer to packed byte string */
            from = THISFROM;
            if (!NIL_P(from)) {
                StringValue(from);
                if (RSTRING_LEN(from) &lt; len) {
                    rb_raise(rb_eArgError, &quot;too short buffer for P(%ld for %ld)&quot;,
                             RSTRING_LEN(from), len);
                }
            }
            len = 1;
            /* FALL THROUGH */
          case 'p':            /* pointer to string */
            while (len-- &gt; 0) {
                char *t;
                from = NEXTFROM;
                if (NIL_P(from)) {
                    t = 0;
                }
                else {
                    t = StringValuePtr(from);
                    rb_obj_taint(from);
                }
                if (!associates) {
                    associates = rb_ary_new();
                }
                rb_ary_push(associates, from);
                rb_str_buf_cat(res, (char*)&amp;t, sizeof(char*));
            }
            break;

          case 'w':            /* BER compressed integer  */
            while (len-- &gt; 0) {
                VALUE buf = rb_str_new(0, 0);
                size_t numbytes;
                int sign;
                char *cp;

                from = NEXTFROM;
                from = rb_to_int(from);
                numbytes = rb_absint_numwords(from, 7, NULL);
                if (numbytes == 0)
                    numbytes = 1;
                buf = rb_str_new(NULL, numbytes);

                sign = rb_integer_pack(from, RSTRING_PTR(buf), RSTRING_LEN(buf), 1, 1, INTEGER_PACK_BIG_ENDIAN);

                if (sign &lt; 0)
                    rb_raise(rb_eArgError, &quot;can't compress negative numbers&quot;);
                if (sign == 2)
                    rb_bug(&quot;buffer size problem?&quot;);

                cp = RSTRING_PTR(buf);
                while (1 &lt; numbytes) {
                  *cp |= 0x80;
                  cp++;
                  numbytes--;
                }

                rb_str_buf_cat(res, RSTRING_PTR(buf), RSTRING_LEN(buf));
            }
            break;

          default: {
            char unknown[5];
            if (ISPRINT(type)) {
                unknown[0] = type;
                unknown[1] = '\0';
            }
            else {
                snprintf(unknown, sizeof(unknown), &quot;\\x%.2x&quot;, type &amp; 0xff);
            }
            rb_warning(&quot;unknown pack directive '%s' in '% &quot;PRIsVALUE&quot;'&quot;,
                       unknown, fmt);
            break;
          }
        }
    }

    if (associates) {
        str_associate(res, associates);
    }
    OBJ_INFECT(res, fmt);
    switch (enc_info) {
      case 1:
        ENCODING_CODERANGE_SET(res, rb_usascii_encindex(), ENC_CODERANGE_7BIT);
        break;
      case 2:
        rb_enc_set_index(res, rb_utf8_encindex());
        break;
      default:
        /* do nothing, keep ASCII-8BIT */
        break;
    }
    return res;
}
            </pre> 
            </div><!-- pack-source -->
            
          </div>

          

          
        </div><!-- pack-method -->
      
        <div id="permutation-method" class="method-detail ">
          <a name="method-i-permutation"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">permutation { |p| block }          &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation                        &rarr; Enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation(n) { |p| block }       &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation(n)                     &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>When invoked with a block, yield all permutations of length <code>n</code>
of the elements of the array, then return the array itself.</p>

<p>If <code>n</code> is not specified, yield all permutations of all elements.</p>

<p>The implementation makes no guarantees about the order in which the
permutations are yielded.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>.<span class="ruby-identifier">to_a</span>    <span class="ruby-comment">#=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">1</span>).<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; [[1],[2],[3]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">2</span>).<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">3</span>).<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; [[]] # one permutation of length 0</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">permutation</span>(<span class="ruby-value">4</span>).<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#=&gt; []   # no permutations of length 4</span>
</pre>
            

            
            <div class="method-source-code" id="permutation-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_permutation(int argc, VALUE *argv, VALUE ary)
{
    VALUE num;
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_permutation_size);   /* Return enumerator if no block */
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);
    r = NIL_P(num) ? n : NUM2LONG(num);   /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = (long*)ALLOCV(t0, r*sizeof(long)+n*sizeof(char));
        char *used = (char*)(p + r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        MEMZERO(used, char, n); /* initialize array */

        permute0(n, r, p, used, ary0); /* compute and yield permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}
            </pre> 
            </div><!-- permutation-source -->
            
          </div>

          

          
        </div><!-- permutation-method -->
      
        <div id="pop-method" class="method-detail ">
          <a name="method-i-pop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pop    &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">pop(n) &rarr; new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes the last element from <code>self</code> and returns it, or
<code>nil</code> if the array is empty.</p>

<p>If a number <code>n</code> is given, returns an array of the last
<code>n</code> elements (or less) just like <code>array.slice!(-n,
n)</code> does. See also <a href="Array.html#method-i-push">#push</a> for
the opposite effect.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>     <span class="ruby-comment">#=&gt; &quot;d&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">pop</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [&quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>         <span class="ruby-comment">#=&gt; [&quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="pop-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_pop_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;

    if (argc == 0) {
        return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
    return result;
}
            </pre> 
            </div><!-- pop-source -->
            
          </div>

          

          
        </div><!-- pop-method -->
      
        <div id="product-method" class="method-detail ">
          <a name="method-i-product"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">product(other_ary, ...)                &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">product(other_ary, ...) { |p| block }  &rarr; ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of all combinations of elements from all arrays.</p>

<p>The length of the returned array is the product of the length of
<code>self</code> and the argument arrays.</p>

<p>If given a block, <a href="Array.html#method-i-product">product</a> will
yield all combinations and return <code>self</code> instead.</p>

<pre class="ruby">[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">4</span>,<span class="ruby-value">5</span>])     <span class="ruby-comment">#=&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">1</span>,<span class="ruby-value">2</span>])       <span class="ruby-comment">#=&gt; [[1,1],[1,2],[2,1],[2,2]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">product</span>([<span class="ruby-value">3</span>,<span class="ruby-value">4</span>],[<span class="ruby-value">5</span>,<span class="ruby-value">6</span>]) <span class="ruby-comment">#=&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],</span>
                           <span class="ruby-comment">#     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">product</span>()            <span class="ruby-comment">#=&gt; [[1],[2]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">product</span>([])          <span class="ruby-comment">#=&gt; []</span>
</pre>
            

            
            <div class="method-source-code" id="product-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_product(int argc, VALUE *argv, VALUE ary)
{
    int n = argc+1;    /* How many arrays we're operating on */
    volatile VALUE t0 = tmpary(n);
    volatile VALUE t1 = tmpbuf(n, sizeof(int));
    VALUE *arrays = RARRAY_PTR(t0); /* The arrays we're computing the product of */
    int *counters = (int*)RSTRING_PTR(t1); /* The current position in each one */
    VALUE result = Qnil;      /* The array we'll be returning, when no block given */
    long i,j;
    long resultlen = 1;

    RBASIC_CLEAR_CLASS(t0);
    RBASIC_CLEAR_CLASS(t1);

    /* initialize the arrays of arrays */
    ARY_SET_LEN(t0, n);
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = Qnil;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);

    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Otherwise, allocate and fill in an array of results */
    if (rb_block_given_p()) {
        /* Make defensive copies of arrays; exit if any is empty */
        for (i = 0; i &lt; n; i++) {
            if (RARRAY_LEN(arrays[i]) == 0) goto done;
            arrays[i] = ary_make_shared_copy(arrays[i]);
        }
    }
    else {
        /* Compute the length of the result array; return [] if any is empty */
        for (i = 0; i &lt; n; i++) {
            long k = RARRAY_LEN(arrays[i]);
            if (k == 0) {
                result = rb_ary_new2(0);
                goto done;
            }
            if (MUL_OVERFLOW_LONG_P(resultlen, k))
                rb_raise(rb_eRangeError, &quot;too big to product&quot;);
            resultlen *= k;
        }
        result = rb_ary_new2(resultlen);
    }
    for (;;) {
        int m;
        /* fill in one subarray */
        VALUE subarray = rb_ary_new2(n);
        for (j = 0; j &lt; n; j++) {
            rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
        }

        /* put it on the result array */
        if (NIL_P(result)) {
            FL_SET(t0, FL_USER5);
            rb_yield(subarray);
            if (! FL_TEST(t0, FL_USER5)) {
                rb_raise(rb_eRuntimeError, &quot;product reentered&quot;);
            }
            else {
                FL_UNSET(t0, FL_USER5);
            }
        }
        else {
            rb_ary_push(result, subarray);
        }

        /*
         * Increment the last counter.  If it overflows, reset to 0
         * and increment the one before it.
         */
        m = n-1;
        counters[m]++;
        while (counters[m] == RARRAY_LEN(arrays[m])) {
            counters[m] = 0;
            /* If the first counter overflows, we are done */
            if (--m &lt; 0) goto done;
            counters[m]++;
        }
    }
done:
    tmpary_discard(t0);
    tmpbuf_discard(t1);

    return NIL_P(result) ? ary : result;
}
            </pre> 
            </div><!-- product-source -->
            
          </div>

          

          
        </div><!-- product-method -->
      
        <div id="push-method" class="method-detail ">
          <a name="method-i-push"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">push(obj, ... )   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Append — Pushes the given object(s) on to the end of this array. This
expression returns the array itself, so several appends may be chained
together. See also <a href="Array.html#method-i-pop">#pop</a> for the
opposite effect.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">push</span>(<span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span>, <span class="ruby-string">&quot;f&quot;</span>)
        <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>,].<span class="ruby-identifier">push</span>(<span class="ruby-value">4</span>).<span class="ruby-identifier">push</span>(<span class="ruby-value">5</span>)
        <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5]</span>
</pre>
            

            
            <div class="method-source-code" id="push-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_push_m(int argc, VALUE *argv, VALUE ary)
{
    return rb_ary_cat(ary, argv, argc);
}
            </pre> 
            </div><!-- push-source -->
            
          </div>

          

          
        </div><!-- push-method -->
      
        <div id="rassoc-method" class="method-detail ">
          <a name="method-i-rassoc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rassoc(obj) &rarr; new_ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Searches through the array whose elements are also arrays.</p>

<p>Compares <code>obj</code> with the second element of each contained array
using <code>obj.==</code>.</p>

<p>Returns the first contained array that matches <code>obj</code>.</p>

<p>See also <a href="Array.html#method-i-assoc">#assoc</a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ [ <span class="ruby-value">1</span>, <span class="ruby-string">&quot;one&quot;</span>], [<span class="ruby-value">2</span>, <span class="ruby-string">&quot;two&quot;</span>], [<span class="ruby-value">3</span>, <span class="ruby-string">&quot;three&quot;</span>], [<span class="ruby-string">&quot;ii&quot;</span>, <span class="ruby-string">&quot;two&quot;</span>] ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-string">&quot;two&quot;</span>)    <span class="ruby-comment">#=&gt; [2, &quot;two&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-string">&quot;four&quot;</span>)   <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="rassoc-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_rassoc(VALUE ary, VALUE value)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = RARRAY_AREF(ary, i);
        if (RB_TYPE_P(v, T_ARRAY) &amp;&amp;
            RARRAY_LEN(v) &gt; 1 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 1), value))
            return v;
    }
    return Qnil;
}
            </pre> 
            </div><!-- rassoc-source -->
            
          </div>

          

          
        </div><!-- rassoc-method -->
      
        <div id="reject-method" class="method-detail ">
          <a name="method-i-reject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject  {|item| block }  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reject                   &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array containing the items in <code>self</code> for which the
given block is not <code>true</code>.</p>

<p>See also <a href="Array.html#method-i-delete_if">#delete_if</a></p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>
            

            
            <div class="method-source-code" id="reject-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reject(VALUE ary)
{
    VALUE rejected_ary;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rejected_ary = rb_ary_new();
    ary_reject(ary, rejected_ary);
    return rejected_ary;
}
            </pre> 
            </div><!-- reject-source -->
            
          </div>

          

          
        </div><!-- reject-method -->
      
        <div id="reject-21-method" class="method-detail ">
          <a name="method-i-reject-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject! { |item| block }  &rarr; ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reject!                   &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Equivalent to <a href="Array.html#method-i-delete_if">#delete_if</a>,
deleting elements from <code>self</code> for which the block evaluates to
<code>true</code>, but returns <code>nil</code> if no changes were made.</p>

<p>The array is changed instantly every time the block is called, not after
the iteration is over.</p>

<p>See also <a href="Enumerable.html#method-i-reject">Enumerable#reject</a>
and <a href="Array.html#method-i-delete_if">#delete_if</a>.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>
            

            
            <div class="method-source-code" id="reject-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reject_bang(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    return ary_reject_bang(ary);
}
            </pre> 
            </div><!-- reject-21-source -->
            
          </div>

          

          
        </div><!-- reject-21-method -->
      
        <div id="repeated_combination-method" class="method-detail ">
          <a name="method-i-repeated_combination"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">repeated_combination(n) { |c| block } &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">repeated_combination(n)               &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>When invoked with a block, yields all repeated combinations of length
<code>n</code> of elements from the array and then returns the array
itself.</p>

<p>The implementation makes no guarantees about the order in which the
repeated combinations are yielded.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">1</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1], [2], [3]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">2</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">3</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],</span>
                                <span class="ruby-comment">#    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">4</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],</span>
                                <span class="ruby-comment">#    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],</span>
                                <span class="ruby-comment">#    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_combination</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[]] # one combination of length 0</span>
</pre>
            

            
            <div class="method-source-code" id="repeated_combination-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_repeated_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);                 /* Combination size from argument */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_combination_size);   /* Return enumerator if no block */
    len = RARRAY_LEN(ary);
    if (n &lt; 0) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; len; i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else if (len == 0) {
        /* yield nothing */
    }
    else {
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, n);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rcombinate0(len, n, p, n, ary0); /* compute and yield repeated combinations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}
            </pre> 
            </div><!-- repeated_combination-source -->
            
          </div>

          

          
        </div><!-- repeated_combination-method -->
      
        <div id="repeated_permutation-method" class="method-detail ">
          <a name="method-i-repeated_permutation"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">repeated_permutation(n) { |p| block } &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">repeated_permutation(n)               &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>When invoked with a block, yield all repeated permutations of length
<code>n</code> of the elements of the array, then return the array itself.</p>

<p>The implementation makes no guarantees about the order in which the
repeated permutations are yielded.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">1</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1], [2]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">2</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,1],[1,2],[2,1],[2,2]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">3</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[1,1,1],[1,1,2],[1,2,1],[1,2,2],</span>
                                <span class="ruby-comment">#    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">repeated_permutation</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">to_a</span>  <span class="ruby-comment">#=&gt; [[]] # one permutation of length 0</span>
</pre>
            

            
            <div class="method-source-code" id="repeated_permutation-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_repeated_permutation(VALUE ary, VALUE num)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_permutation_size);      /* Return Enumerator if no block */
    r = NUM2LONG(num);                    /* Permutation size from argument */

    if (r &lt; 0) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r * sizeof(long));
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rpermute0(n, r, p, ary0); /* compute and yield repeated permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}
            </pre> 
            </div><!-- repeated_permutation-source -->
            
          </div>

          

          
        </div><!-- repeated_permutation-method -->
      
        <div id="replace-method" class="method-detail ">
          <a name="method-i-replace"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_ary)  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the contents of <code>self</code> with the contents of
<code>other_ary</code>, truncating or expanding if necessary.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">replace</span>([ <span class="ruby-string">&quot;x&quot;</span>, <span class="ruby-string">&quot;y&quot;</span>, <span class="ruby-string">&quot;z&quot;</span> ])   <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
<span class="ruby-identifier">a</span>                              <span class="ruby-comment">#=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="replace-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    if (RARRAY_LEN(orig) &lt;= RARRAY_EMBED_LEN_MAX) {
        VALUE shared = 0;

        if (ARY_OWNS_HEAP_P(copy)) {
            RARRAY_PTR_USE(copy, ptr, ruby_sized_xfree(ptr, ARY_HEAP_SIZE(copy)));
        }
        else if (ARY_SHARED_P(copy)) {
            shared = ARY_SHARED(copy);
            FL_UNSET_SHARED(copy);
        }
        FL_SET_EMBED(copy);
        ary_memcpy(copy, 0, RARRAY_LEN(orig), RARRAY_CONST_PTR(orig));
        if (shared) {
            rb_ary_decrement_share(shared);
        }
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
    }
    else {
        VALUE shared = ary_make_shared(orig);
        if (ARY_OWNS_HEAP_P(copy)) {
            RARRAY_PTR_USE(copy, ptr, ruby_sized_xfree(ptr, ARY_HEAP_SIZE(copy)));
        }
        else {
            rb_ary_unshare_safe(copy);
        }
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, RARRAY_CONST_PTR(orig));
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
        rb_ary_set_shared(copy, shared);
    }
    return copy;
}
            </pre> 
            </div><!-- replace-source -->
            
          </div>

          

          
        </div><!-- replace-method -->
      
        <div id="reverse-method" class="method-detail ">
          <a name="method-i-reverse"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse    &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array containing <code>self</code>‘s elements in reverse
order.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ].<span class="ruby-identifier">reverse</span>   <span class="ruby-comment">#=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
[ <span class="ruby-value">1</span> ].<span class="ruby-identifier">reverse</span>               <span class="ruby-comment">#=&gt; [1]</span>
</pre>
            

            
            <div class="method-source-code" id="reverse-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reverse_m(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE dup = rb_ary_new2(len);

    if (len &gt; 0) {
        const VALUE *p1 = RARRAY_CONST_PTR(ary);
        VALUE *p2 = (VALUE *)RARRAY_CONST_PTR(dup) + len - 1;
        do *p2-- = *p1++; while (--len &gt; 0);
    }
    ARY_SET_LEN(dup, RARRAY_LEN(ary));
    return dup;
}
            </pre> 
            </div><!-- reverse-source -->
            
          </div>

          

          
        </div><!-- reverse-method -->
      
        <div id="reverse-21-method" class="method-detail ">
          <a name="method-i-reverse-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse!   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reverses <code>self</code> in place.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse!</span>       <span class="ruby-comment">#=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
<span class="ruby-identifier">a</span>                <span class="ruby-comment">#=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="reverse-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reverse_bang(VALUE ary)
{
    return rb_ary_reverse(ary);
}
            </pre> 
            </div><!-- reverse-21-source -->
            
          </div>

          

          
        </div><!-- reverse-21-method -->
      
        <div id="reverse_each-method" class="method-detail ">
          <a name="method-i-reverse_each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each { |item| block }  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each                   &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Same as <a href="Array.html#method-i-each">#each</a>, but traverses
<code>self</code> in reverse order.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">x</span>, <span class="ruby-string">&quot; &quot;</span> }
</pre>

<p>produces:</p>

<pre class="ruby"><span class="ruby-identifier">c</span> <span class="ruby-identifier">b</span> <span class="ruby-identifier">a</span>
</pre>
            

            
            <div class="method-source-code" id="reverse_each-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_reverse_each(VALUE ary)
{
    long len;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    len = RARRAY_LEN(ary);
    while (len--) {
        long nlen;
        rb_yield(RARRAY_AREF(ary, len));
        nlen = RARRAY_LEN(ary);
        if (nlen &lt; len) {
            len = nlen;
        }
    }
    return ary;
}
            </pre> 
            </div><!-- reverse_each-source -->
            
          </div>

          

          
        </div><!-- reverse_each-method -->
      
        <div id="rindex-method" class="method-detail ">
          <a name="method-i-rindex"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rindex(obj)             &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">rindex { |item| block } &rarr;  int or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">rindex                  &rarr;  Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <em>index</em> of the last object in <code>self</code>
<code>==</code> to <code>obj</code>.</p>

<p>If a block is given instead of an argument, returns the <em>index</em> of
the first object for which the block returns <code>true</code>, starting
from the last object.</p>

<p>Returns <code>nil</code> if no match is found.</p>

<p>See also <a href="Array.html#method-i-index">#index</a>.</p>

<p>If neither block nor argument is given, an <a
href="Enumerator.html">Enumerator</a> is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&quot;b&quot;</span>)             <span class="ruby-comment">#=&gt; 3</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&quot;z&quot;</span>)             <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rindex</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;b&quot;</span> } <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="rindex-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_rindex(int argc, VALUE *argv, VALUE ary)
{
    const VALUE *ptr;
    VALUE val;
    long i = RARRAY_LEN(ary), len;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        while (i--) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i))))
                return LONG2NUM(i);
            if (i &gt; (len = RARRAY_LEN(ary))) {
                i = len;
            }
        }
        return Qnil;
    }
    rb_check_arity(argc, 0, 1);
    val = argv[0];
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    ptr = RARRAY_CONST_PTR(ary);
    while (i--) {
        VALUE e = ptr[i];
        switch (rb_equal_opt(e, val)) {
          case Qundef:
            if (!rb_equal(e, val)) break;
          case Qtrue:
            return LONG2NUM(i);
          case Qfalse:
            continue;
        }
        if (i &gt; (len = RARRAY_LEN(ary))) {
            i = len;
        }
        ptr = RARRAY_CONST_PTR(ary);
    }
    return Qnil;
}
            </pre> 
            </div><!-- rindex-source -->
            
          </div>

          

          
        </div><!-- rindex-method -->
      
        <div id="rotate-method" class="method-detail ">
          <a name="method-i-rotate"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rotate(count=1)    &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array by rotating <code>self</code> so that the element at
<code>count</code> is the first element of the new array.</p>

<p>If <code>count</code> is negative then it rotates in the opposite
direction, starting from the end of <code>self</code> where <code>-1</code>
is the last element.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>         <span class="ruby-comment">#=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]</span>
<span class="ruby-identifier">a</span>                <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>(<span class="ruby-value">2</span>)      <span class="ruby-comment">#=&gt; [&quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate</span>(<span class="ruby-value">-3</span>)     <span class="ruby-comment">#=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="rotate-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_rotate_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE rotated;
    const VALUE *ptr;
    long len, cnt = 1;

    switch (argc) {
      case 1: cnt = NUM2LONG(argv[0]);
      case 0: break;
      default: rb_scan_args(argc, argv, &quot;01&quot;, NULL);
    }

    len = RARRAY_LEN(ary);
    rotated = rb_ary_new2(len);
    if (len &gt; 0) {
        cnt = rotate_count(cnt, len);
        ptr = RARRAY_CONST_PTR(ary);
        len -= cnt;
        ary_memcpy(rotated, 0, len, ptr + cnt);
        ary_memcpy(rotated, len, cnt, ptr);
    }
    ARY_SET_LEN(rotated, RARRAY_LEN(ary));
    return rotated;
}
            </pre> 
            </div><!-- rotate-source -->
            
          </div>

          

          
        </div><!-- rotate-method -->
      
        <div id="rotate-21-method" class="method-detail ">
          <a name="method-i-rotate-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rotate!(count=1)   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Rotates <code>self</code> in place so that the element at
<code>count</code> comes first, and returns <code>self</code>.</p>

<p>If <code>count</code> is negative then it rotates in the opposite
direction, starting from the end of the array where <code>-1</code> is the
last element.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span>        <span class="ruby-comment">#=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]</span>
<span class="ruby-identifier">a</span>                <span class="ruby-comment">#=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">2</span>)     <span class="ruby-comment">#=&gt; [&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">rotate!</span>(<span class="ruby-value">-3</span>)    <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="rotate-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_rotate_bang(int argc, VALUE *argv, VALUE ary)
{
    long n = 1;

    switch (argc) {
      case 1: n = NUM2LONG(argv[0]);
      case 0: break;
      default: rb_scan_args(argc, argv, &quot;01&quot;, NULL);
    }
    rb_ary_rotate(ary, n);
    return ary;
}
            </pre> 
            </div><!-- rotate-21-source -->
            
          </div>

          

          
        </div><!-- rotate-21-method -->
      
        <div id="sample-method" class="method-detail ">
          <a name="method-i-sample"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sample                  &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sample(random: rng)     &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sample(n)               &rarr; new_ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sample(n, random: rng)  &rarr; new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Choose a random element or <code>n</code> random elements from the array.</p>

<p>The elements are chosen by using random and unique indices into the array
in order to ensure that an element doesn’t repeat itself unless the array
already contained duplicate elements.</p>

<p>If the array is empty the first form returns <code>nil</code> and the
second form returns an empty array.</p>

<p>The optional <code>rng</code> argument will be used as the random number
generator.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>         <span class="ruby-comment">#=&gt; 7</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sample</span>(<span class="ruby-value">4</span>)      <span class="ruby-comment">#=&gt; [6, 4, 2, 5]</span>
</pre>
            

            
            <div class="method-source-code" id="sample-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_sample(int argc, VALUE *argv, VALUE ary)
{
    VALUE nv, result;
    VALUE opts, randgen = rb_cRandom;
    long n, len, i, j, k, idx[10];
    long rnds[numberof(idx)];

    if (OPTHASH_GIVEN_P(opts)) {
        VALUE rnd;
        ID keyword_ids[1];

        keyword_ids[0] = id_random;
        rb_get_kwargs(opts, keyword_ids, 0, 1, &amp;rnd);
        if (rnd != Qundef) {
            randgen = rnd;
        }
    }
    len = RARRAY_LEN(ary);
    if (argc == 0) {
        if (len &lt; 2)
            i = 0;
        else
            i = RAND_UPTO(len);

        return rb_ary_elt(ary, i);
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;nv);
    n = NUM2LONG(nv);
    if (n &lt; 0) rb_raise(rb_eArgError, &quot;negative sample number&quot;);
    if (n &gt; len) n = len;
    if (n &lt;= numberof(idx)) {
        for (i = 0; i &lt; n; ++i) {
            rnds[i] = RAND_UPTO(len - i);
        }
    }
    k = len;
    len = RARRAY_LEN(ary);
    if (len &lt; k &amp;&amp; n &lt;= numberof(idx)) {
        for (i = 0; i &lt; n; ++i) {
            if (rnds[i] &gt;= len) return rb_ary_new_capa(0);
        }
    }
    if (n &gt; len) n = len;
    switch (n) {
      case 0:
        return rb_ary_new_capa(0);
      case 1:
        i = rnds[0];
        return rb_ary_new_from_values(1, &amp;RARRAY_AREF(ary, i));
      case 2:
        i = rnds[0];
        j = rnds[1];
        if (j &gt;= i) j++;
        return rb_ary_new_from_args(2, RARRAY_AREF(ary, i), RARRAY_AREF(ary, j));
      case 3:
        i = rnds[0];
        j = rnds[1];
        k = rnds[2];
        {
            long l = j, g = i;
            if (j &gt;= i) l = i, g = ++j;
            if (k &gt;= l &amp;&amp; (++k &gt;= g)) ++k;
        }
        return rb_ary_new_from_args(3, RARRAY_AREF(ary, i), RARRAY_AREF(ary, j), RARRAY_AREF(ary, k));
    }
    if (n &lt;= numberof(idx)) {
        long sorted[numberof(idx)];
        sorted[0] = idx[0] = rnds[0];
        for (i=1; i&lt;n; i++) {
            k = rnds[i];
            for (j = 0; j &lt; i; ++j) {
                if (k &lt; sorted[j]) break;
                ++k;
            }
            memmove(&amp;sorted[j+1], &amp;sorted[j], sizeof(sorted[0])*(i-j));
            sorted[j] = idx[i] = k;
        }
        result = rb_ary_new_capa(n);
        RARRAY_PTR_USE(result, ptr_result, {
            for (i=0; i&lt;n; i++) {
                ptr_result[i] = RARRAY_AREF(ary, idx[i]);
            }
        });
    }
    else {
        result = rb_ary_dup(ary);
        RBASIC_CLEAR_CLASS(result);
        RB_GC_GUARD(ary);
        RARRAY_PTR_USE(result, ptr_result, {
            for (i=0; i&lt;n; i++) {
                j = RAND_UPTO(len-i) + i;
                nv = ptr_result[j];
                ptr_result[j] = ptr_result[i];
                ptr_result[i] = nv;
            }
        });
        RBASIC_SET_CLASS_RAW(result, rb_cArray);
    }
    ARY_SET_LEN(result, n);

    return result;
}
            </pre> 
            </div><!-- sample-source -->
            
          </div>

          

          
        </div><!-- sample-method -->
      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select { |item| block } &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select                  &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array containing all elements of <code>ary</code> for which
the given <code>block</code> returns a true value.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<pre class="ruby">[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>].<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">num</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">num</span>.<span class="ruby-identifier">even?</span>  }   <span class="ruby-comment">#=&gt; [2, 4]</span>

<span class="ruby-identifier">a</span> = <span class="ruby-node">%w{ a b c d e f }</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/[aeiou]/</span> }  <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;e&quot;]</span>
</pre>

<p>See also <a href="Enumerable.html#method-i-select">Enumerable#select</a>.</p>
            

            
            <div class="method-source-code" id="select-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_select(VALUE ary)
{
    VALUE result;
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    result = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
            rb_ary_push(result, rb_ary_elt(ary, i));
        }
    }
    return result;
}
            </pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->
      
        <div id="select-21-method" class="method-detail ">
          <a name="method-i-select-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select!  {|item| block } &rarr; ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select!                  &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the given block passing in successive elements from
<code>self</code>, deleting elements for which the block returns a
<code>false</code> value.</p>

<p>If changes were made, it will return <code>self</code>, otherwise it
returns <code>nil</code>.</p>

<p>See also <a href="Array.html#method-i-keep_if">#keep_if</a></p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>
            

            
            <div class="method-source-code" id="select-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_select_bang(VALUE ary)
{
    long i1, i2;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE v = RARRAY_AREF(ary, i1);
        if (!RTEST(rb_yield(v))) continue;
        if (i1 != i2) {
            rb_ary_store(ary, i2, v);
        }
        i2++;
    }

    if (i1 == i2) return Qnil;
    if (i2 &lt; i1)
        ARY_SET_LEN(ary, i2);
    return ary;
}
            </pre> 
            </div><!-- select-21-source -->
            
          </div>

          

          
        </div><!-- select-21-method -->
      
        <div id="shift-method" class="method-detail ">
          <a name="method-i-shift"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shift    &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">shift(n) &rarr; new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes the first element of <code>self</code> and returns it (shifting all
other elements down by one). Returns <code>nil</code> if the array is
empty.</p>

<p>If a number <code>n</code> is given, returns an array of the first
<code>n</code> elements (or less) just like <code>array.slice!(0, n)</code>
does. With <code>ary</code> containing only the remainder elements, not
including what was shifted to <code>new_ary</code>. See also <a
href="Array.html#method-i-unshift">#unshift</a> for the opposite effect.</p>

<pre class="ruby"><span class="ruby-identifier">args</span> = [ <span class="ruby-string">&quot;-m&quot;</span>, <span class="ruby-string">&quot;-q&quot;</span>, <span class="ruby-string">&quot;filename&quot;</span> ]
<span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>     <span class="ruby-comment">#=&gt; &quot;-m&quot;</span>
<span class="ruby-identifier">args</span>           <span class="ruby-comment">#=&gt; [&quot;-q&quot;, &quot;filename&quot;]</span>

<span class="ruby-identifier">args</span> = [ <span class="ruby-string">&quot;-m&quot;</span>, <span class="ruby-string">&quot;-q&quot;</span>, <span class="ruby-string">&quot;filename&quot;</span> ]
<span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [&quot;-m&quot;, &quot;-q&quot;]</span>
<span class="ruby-identifier">args</span>           <span class="ruby-comment">#=&gt; [&quot;filename&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="shift-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_shift_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;
    long n;

    if (argc == 0) {
        return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    n = RARRAY_LEN(result);
    if (ARY_SHARED_P(ary)) {
        if (ARY_SHARED_OCCUPIED(ARY_SHARED(ary))) {
            ary_mem_clear(ary, 0, n);
        }
        ARY_INCREASE_PTR(ary, n);
    }
    else {
        RARRAY_PTR_USE(ary, ptr, {
            MEMMOVE(ptr, ptr + n, VALUE, RARRAY_LEN(ary)-n);
        }); /* WB: no new reference */
    }
    ARY_INCREASE_LEN(ary, -n);

    return result;
}
            </pre> 
            </div><!-- shift-source -->
            
          </div>

          

          
        </div><!-- shift-method -->
      
        <div id="shuffle-method" class="method-detail ">
          <a name="method-i-shuffle"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shuffle              &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">shuffle(random: rng) &rarr; new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array with elements of <code>self</code> shuffled.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]           <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span>                 <span class="ruby-comment">#=&gt; [2, 3, 1]</span>
<span class="ruby-identifier">a</span>                         <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>

<p>The optional <code>rng</code> argument will be used as the random number
generator.</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle</span>(<span class="ruby-identifier">random</span><span class="ruby-operator">:</span> <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>))  <span class="ruby-comment">#=&gt; [1, 3, 2]</span>
</pre>
            

            
            <div class="method-source-code" id="shuffle-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_shuffle(int argc, VALUE *argv, VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_shuffle_bang(argc, argv, ary);
    return ary;
}
            </pre> 
            </div><!-- shuffle-source -->
            
          </div>

          

          
        </div><!-- shuffle-method -->
      
        <div id="shuffle-21-method" class="method-detail ">
          <a name="method-i-shuffle-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shuffle!              &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">shuffle!(random: rng) &rarr; ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Shuffles elements in <code>self</code> in place.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span> ]           <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle!</span>                <span class="ruby-comment">#=&gt; [2, 3, 1]</span>
<span class="ruby-identifier">a</span>                         <span class="ruby-comment">#=&gt; [2, 3, 1]</span>
</pre>

<p>The optional <code>rng</code> argument will be used as the random number
generator.</p>

<pre class="ruby"><span class="ruby-identifier">a</span>.<span class="ruby-identifier">shuffle!</span>(<span class="ruby-identifier">random</span><span class="ruby-operator">:</span> <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>))  <span class="ruby-comment">#=&gt; [1, 3, 2]</span>
</pre>
            

            
            <div class="method-source-code" id="shuffle-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_shuffle_bang(int argc, VALUE *argv, VALUE ary)
{
    VALUE opts, randgen = rb_cRandom;
    long i, len;

    if (OPTHASH_GIVEN_P(opts)) {
        VALUE rnd;
        ID keyword_ids[1];

        keyword_ids[0] = id_random;
        rb_get_kwargs(opts, keyword_ids, 0, 1, &amp;rnd);
        if (rnd != Qundef) {
            randgen = rnd;
        }
    }
    rb_check_arity(argc, 0, 0);
    rb_ary_modify(ary);
    i = len = RARRAY_LEN(ary);
    RARRAY_PTR_USE(ary, ptr, {
        while (i) {
            long j = RAND_UPTO(i);
            VALUE tmp;
            if (len != RARRAY_LEN(ary) || ptr != RARRAY_CONST_PTR(ary)) {
                rb_raise(rb_eRuntimeError, &quot;modified during shuffle&quot;);
            }
            tmp = ptr[--i];
            ptr[i] = ptr[j];
            ptr[j] = tmp;
        }
    }); /* WB: no new reference */
    return ary;
}
            </pre> 
            </div><!-- shuffle-21-source -->
            
          </div>

          

          
        </div><!-- shuffle-21-method -->
      
        <div id="size-method" class="method-detail method-alias">
          <a name="method-i-size"></a>

          
          <div class="method-heading">
            <span class="method-name">size</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Array.html#method-i-length">length</a>
          </div>
          
        </div><!-- size-method -->
      
        <div id="slice-method" class="method-detail ">
          <a name="method-i-slice"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice(index)          &rarr; obj     or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(start, length)  &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(range)          &rarr; new_ary or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Element Reference — Returns the element at <code>index</code>, or returns a
subarray starting at the <code>start</code> index and continuing for
<code>length</code> elements, or returns a subarray specified by
<code>range</code> of indices.</p>

<p>Negative indices count backward from the end of the array (-1 is the last
element).  For <code>start</code> and <code>range</code> cases the starting
index is just before an element.  Additionally, an empty array is returned
when the starting index for an element range is at the end of the array.</p>

<p>Returns <code>nil</code> if the index (or starting index) are out of range.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;e&quot;</span> ]
<span class="ruby-identifier">a</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">+</span>  <span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>]    <span class="ruby-comment">#=&gt; &quot;cab&quot;</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>]                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]                <span class="ruby-comment">#=&gt; [ &quot;b&quot;, &quot;c&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>]                <span class="ruby-comment">#=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>]                <span class="ruby-comment">#=&gt; [ &quot;e&quot; ]</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]               <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">-3</span>, <span class="ruby-value">3</span>]               <span class="ruby-comment">#=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]</span>
<span class="ruby-comment"># special cases</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span>]                   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">6</span>, <span class="ruby-value">1</span>]                <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span>, <span class="ruby-value">1</span>]                <span class="ruby-comment">#=&gt; []</span>
<span class="ruby-identifier">a</span>[<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]               <span class="ruby-comment">#=&gt; []</span>
</pre>
            

            
            <div class="method-source-code" id="slice-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_aref(int argc, const VALUE *argv, VALUE ary)
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        if (beg &lt; 0) {
            beg += RARRAY_LEN(ary);
        }
        return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
        rb_scan_args(argc, argv, &quot;11&quot;, NULL, NULL);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
        return rb_ary_entry(ary, FIX2LONG(arg));
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY_LEN(ary), 0)) {
      case Qfalse:
        break;
      case Qnil:
        return Qnil;
      default:
        return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}
            </pre> 
            </div><!-- slice-source -->
            
          </div>

          

          
        </div><!-- slice-method -->
      
        <div id="slice-21-method" class="method-detail ">
          <a name="method-i-slice-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice!(index)         &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice!(start, length) &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice!(range)         &rarr; new_ary or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes the element(s) given by an <code>index</code> (optionally up to
<code>length</code> elements) or by a <code>range</code>.</p>

<p>Returns the deleted object (or objects), or <code>nil</code> if the
<code>index</code> is out of range.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">1</span>)     <span class="ruby-comment">#=&gt; &quot;b&quot;</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;c&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">-1</span>)    <span class="ruby-comment">#=&gt; &quot;c&quot;</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment">#=&gt; [&quot;a&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">100</span>)   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">a</span>               <span class="ruby-comment">#=&gt; [&quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="slice-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg1, arg2;
    long pos, len, orig_len;

    rb_ary_modify_check(ary);
    if (argc == 2) {
        pos = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
      delete_pos_len:
        if (len &lt; 0) return Qnil;
        orig_len = RARRAY_LEN(ary);
        if (pos &lt; 0) {
            pos += orig_len;
            if (pos &lt; 0) return Qnil;
        }
        else if (orig_len &lt; pos) return Qnil;
        if (orig_len &lt; pos + len) {
            len = orig_len - pos;
        }
        if (len == 0) return rb_ary_new2(0);
        arg2 = rb_ary_new4(len, RARRAY_CONST_PTR(ary)+pos);
        RBASIC_SET_CLASS(arg2, rb_obj_class(ary));
        rb_ary_splice(ary, pos, len, Qundef);
        return arg2;
    }

    if (argc != 1) {
        /* error report */
        rb_scan_args(argc, argv, &quot;11&quot;, NULL, NULL);
    }
    arg1 = argv[0];

    if (!FIXNUM_P(arg1)) {
        switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
          case Qtrue:
            /* valid range */
            goto delete_pos_len;
          case Qnil:
            /* invalid range */
            return Qnil;
          default:
            /* not a range */
            break;
        }
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}
            </pre> 
            </div><!-- slice-21-source -->
            
          </div>

          

          
        </div><!-- slice-21-method -->
      
        <div id="sort-method" class="method-detail ">
          <a name="method-i-sort"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort                   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort { |a, b| block }  &rarr; new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array created by sorting <code>self</code>.</p>

<p>Comparisons for the sort will be done using the <code>&lt;=&gt;</code>
operator or using an optional code block.</p>

<p>The block must implement a comparison between <code>a</code> and
<code>b</code>, and return <code>-1</code>, when <code>a</code> follows
<code>b</code>, <code>0</code> when <code>a</code> and <code>b</code> are
equivalent, or +<code>1</code> if <code>b</code> follows <code>a</code>.</p>

<p>See also <a href="Enumerable.html#method-i-sort_by">Enumerable#sort_by</a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;e&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;b&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span>                    <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">y</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment">#=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="sort-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_sort(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}
            </pre> 
            </div><!-- sort-source -->
            
          </div>

          

          
        </div><!-- sort-method -->
      
        <div id="sort-21-method" class="method-detail ">
          <a name="method-i-sort-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort!                   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort! { |a, b| block }  &rarr; ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sorts <code>self</code> in place.</p>

<p>Comparisons for the sort will be done using the <code>&lt;=&gt;</code>
operator or using an optional code block.</p>

<p>The block must implement a comparison between <code>a</code> and
<code>b</code>, and return <code>-1</code>, when <code>a</code> follows
<code>b</code>, <code>0</code> when <code>a</code> and <code>b</code> are
equivalent, or +<code>1</code> if <code>b</code> follows <code>a</code>.</p>

<p>See also <a href="Enumerable.html#method-i-sort_by">Enumerable#sort_by</a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;e&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;b&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort!</span>                    <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">y</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment">#=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="sort-21-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_ary_sort_bang(VALUE ary)
{
    rb_ary_modify(ary);
    assert(!ARY_SHARED_P(ary));
    if (RARRAY_LEN(ary) &gt; 1) {
        VALUE tmp = ary_make_substitution(ary); /* only ary refers tmp */
        struct ary_sort_data data;
        long len = RARRAY_LEN(ary);

        RBASIC_CLEAR_CLASS(tmp);
        data.ary = tmp;
        data.opt_methods = 0;
        data.opt_inited = 0;
        RARRAY_PTR_USE(tmp, ptr, {
            ruby_qsort(ptr, len, sizeof(VALUE),
                       rb_block_given_p()?sort_1:sort_2, &amp;data);
        }); /* WB: no new reference */
        rb_ary_modify(ary);
        if (ARY_EMBED_P(tmp)) {
            if (ARY_SHARED_P(ary)) { /* ary might be destructively operated in the given block */
                rb_ary_unshare(ary);
            }
            FL_SET_EMBED(ary);
            ary_memcpy(ary, 0, ARY_EMBED_LEN(tmp), ARY_EMBED_PTR(tmp));
            ARY_SET_LEN(ary, ARY_EMBED_LEN(tmp));
        }
        else {
            if (!ARY_EMBED_P(ary) &amp;&amp; ARY_HEAP_PTR(ary) == ARY_HEAP_PTR(tmp)) {
                FL_UNSET_SHARED(ary);
                ARY_SET_CAPA(ary, RARRAY_LEN(tmp));
            }
            else {
                assert(!ARY_SHARED_P(tmp));
                if (ARY_EMBED_P(ary)) {
                    FL_UNSET_EMBED(ary);
                }
                else if (ARY_SHARED_P(ary)) {
                    /* ary might be destructively operated in the given block */
                    rb_ary_unshare(ary);
                }
                else {
                    ruby_sized_xfree((void *)ARY_HEAP_PTR(ary), ARY_HEAP_SIZE(ary));
                }
                ARY_SET_PTR(ary, RARRAY_CONST_PTR(tmp));
                ARY_SET_HEAP_LEN(ary, len);
                ARY_SET_CAPA(ary, RARRAY_LEN(tmp));
            }
            /* tmp was lost ownership for the ptr */
            FL_UNSET(tmp, FL_FREEZE);
            FL_SET_EMBED(tmp);
            ARY_SET_EMBED_LEN(tmp, 0);
            FL_SET(tmp, FL_FREEZE);
        }
        /* tmp will be GC'ed. */
        RBASIC_SET_CLASS_RAW(tmp, rb_cArray); /* rb_cArray must be marked */
    }
    return ary;
}
            </pre> 
            </div><!-- sort-21-source -->
            
          </div>

          

          
        </div><!-- sort-21-method -->
      
        <div id="sort_by-21-method" class="method-detail ">
          <a name="method-i-sort_by-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort_by! { |obj| block }    &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort_by!                    &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sorts <code>self</code> in place using a set of keys generated by mapping
the values in <code>self</code> through the given block.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>
            

            
            <div class="method-source-code" id="sort_by-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_sort_by_bang(VALUE ary)
{
    VALUE sorted;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    sorted = rb_block_call(ary, rb_intern(&quot;sort_by&quot;), 0, 0, sort_by_i, 0);
    rb_ary_replace(ary, sorted);
    return ary;
}
            </pre> 
            </div><!-- sort_by-21-source -->
            
          </div>

          

          
        </div><!-- sort_by-21-method -->
      
        <div id="take-method" class="method-detail ">
          <a name="method-i-take"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take(n)               &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns first <code>n</code> elements from the array.</p>

<p>If a negative number is given, raises an <a
href="ArgumentError.html">ArgumentError</a>.</p>

<p>See also <a href="Array.html#method-i-drop">#drop</a></p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>
            

            
            <div class="method-source-code" id="take-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_take(VALUE obj, VALUE n)
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }
    return rb_ary_subseq(obj, 0, len);
}
            </pre> 
            </div><!-- take-source -->
            
          </div>

          

          
        </div><!-- take-method -->
      
        <div id="take_while-method" class="method-detail ">
          <a name="method-i-take_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take_while { |arr| block }  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">take_while                  &rarr; Enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes elements to the block until the block returns <code>nil</code> or
<code>false</code>, then stops iterating and returns an array of all prior
elements.</p>

<p>If no block is given, an <a href="Enumerator.html">Enumerator</a> is
returned instead.</p>

<p>See also <a href="Array.html#method-i-drop_while">#drop_while</a></p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }  <span class="ruby-comment">#=&gt; [1, 2]</span>
</pre>
            

            
            <div class="method-source-code" id="take_while-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_take_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}
            </pre> 
            </div><!-- take_while-source -->
            
          </div>

          

          
        </div><!-- take_while-method -->
      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a     &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>self</code>.</p>

<p>If called on a subclass of <a href="Array.html">Array</a>, converts the
receiver to an <a href="Array.html">Array</a> object.</p>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_to_a(VALUE ary)
{
    if (rb_obj_class(ary) != rb_cArray) {
        VALUE dup = rb_ary_new2(RARRAY_LEN(ary));
        rb_ary_replace(dup, ary);
        return dup;
    }
    return ary;
}
            </pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->
      
        <div id="to_ary-method" class="method-detail ">
          <a name="method-i-to_ary"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_ary &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>self</code>.</p>
            

            
            <div class="method-source-code" id="to_ary-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_to_ary_m(VALUE ary)
{
    return ary;
}
            </pre> 
            </div><!-- to_ary-source -->
            
          </div>

          

          
        </div><!-- to_ary-method -->
      
        <div id="to_h-method" class="method-detail ">
          <a name="method-i-to_h"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_h     &rarr; hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the result of interpreting <em>ary</em> as an array of <code>[key,
value]</code> pairs.</p>

<pre class="ruby">[[:<span class="ruby-identifier">foo</span>, :<span class="ruby-identifier">bar</span>], [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]].<span class="ruby-identifier">to_h</span>
  <span class="ruby-comment"># =&gt; {:foo =&gt; :bar, 1 =&gt; 2}</span>
</pre>
            

            
            <div class="method-source-code" id="to_h-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_to_h(VALUE ary)
{
    long i;
    VALUE hash = rb_hash_new();
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        VALUE key_value_pair = rb_check_array_type(rb_ary_elt(ary, i));
        if (NIL_P(key_value_pair)) {
            rb_raise(rb_eTypeError, &quot;wrong element type %s at %ld (expected array)&quot;,
                rb_builtin_class_name(rb_ary_elt(ary, i)), i);
        }
        if (RARRAY_LEN(key_value_pair) != 2) {
            rb_raise(rb_eArgError, &quot;wrong array length at %ld (expected 2, was %ld)&quot;,
                i, RARRAY_LEN(key_value_pair));
        }
        rb_hash_aset(hash, RARRAY_AREF(key_value_pair, 0), RARRAY_AREF(key_value_pair, 1));
    }
    return hash;
}
            </pre> 
            </div><!-- to_h-source -->
            
          </div>

          

          
        </div><!-- to_h-method -->
      
        <div id="to_s-method" class="method-detail method-alias">
          <a name="method-i-to_s"></a>

          
          <div class="method-heading">
            <span class="method-name">to_s</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Array.html#method-i-inspect">inspect</a>
          </div>
          
        </div><!-- to_s-method -->
      
        <div id="transpose-method" class="method-detail ">
          <a name="method-i-transpose"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">transpose &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Assumes that <code>self</code> is an array of arrays and transposes the
rows and columns.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>], [<span class="ruby-value">3</span>,<span class="ruby-value">4</span>], [<span class="ruby-value">5</span>,<span class="ruby-value">6</span>]]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">transpose</span>   <span class="ruby-comment">#=&gt; [[1, 3, 5], [2, 4, 6]]</span>
</pre>

<p>If the length of the subarrays don’t match, an <a
href="IndexError.html">IndexError</a> is raised.</p>
            

            
            <div class="method-source-code" id="transpose-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_transpose(VALUE ary)
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY_LEN(ary);
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
        tmp = to_ary(rb_ary_elt(ary, i));
        if (elen &lt; 0) {                /* first element */
            elen = RARRAY_LEN(tmp);
            result = rb_ary_new2(elen);
            for (j=0; j&lt;elen; j++) {
                rb_ary_store(result, j, rb_ary_new2(alen));
            }
        }
        else if (elen != RARRAY_LEN(tmp)) {
            rb_raise(rb_eIndexError, &quot;element size differs (%ld should be %ld)&quot;,
                     RARRAY_LEN(tmp), elen);
        }
        for (j=0; j&lt;elen; j++) {
            rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
        }
    }
    return result;
}
            </pre> 
            </div><!-- transpose-source -->
            
          </div>

          

          
        </div><!-- transpose-method -->
      
        <div id="uniq-method" class="method-detail ">
          <a name="method-i-uniq"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">uniq                &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">uniq { |item| ... } &rarr; new_ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array by removing duplicate values in <code>self</code>.</p>

<p>If a block is given, it will use the return value of the block for
comparison.</p>

<p>It compares values using their <a href="Array.html#method-i-hash">hash</a>
and <a href="Array.html#method-i-eql-3F">eql?</a> methods for efficiency.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq</span>   <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>

<span class="ruby-identifier">b</span> = [[<span class="ruby-string">&quot;student&quot;</span>,<span class="ruby-string">&quot;sam&quot;</span>], [<span class="ruby-string">&quot;student&quot;</span>,<span class="ruby-string">&quot;george&quot;</span>], [<span class="ruby-string">&quot;teacher&quot;</span>,<span class="ruby-string">&quot;matz&quot;</span>]]
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">uniq</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">first</span> } <span class="ruby-comment"># =&gt; [[&quot;student&quot;, &quot;sam&quot;], [&quot;teacher&quot;, &quot;matz&quot;]]</span>
</pre>
            

            
            <div class="method-source-code" id="uniq-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_uniq(VALUE ary)
{
    VALUE hash, uniq;

    if (RARRAY_LEN(ary) &lt;= 1)
        return rb_ary_dup(ary);
    if (rb_block_given_p()) {
        hash = ary_make_hash_by(ary);
        uniq = rb_hash_values(hash);
    }
    else {
        hash = ary_make_hash(ary);
        uniq = rb_hash_values(hash);
    }
    RBASIC_SET_CLASS(uniq, rb_obj_class(ary));
    ary_recycle_hash(hash);

    return uniq;
}
            </pre> 
            </div><!-- uniq-source -->
            
          </div>

          

          
        </div><!-- uniq-method -->
      
        <div id="uniq-21-method" class="method-detail ">
          <a name="method-i-uniq-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">uniq!                &rarr; ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">uniq! { |item| ... } &rarr; ary or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes duplicate elements from <code>self</code>.</p>

<p>If a block is given, it will use the return value of the block for
comparison.</p>

<p>It compares values using their <a href="Array.html#method-i-hash">hash</a>
and <a href="Array.html#method-i-eql-3F">eql?</a> methods for efficiency.</p>

<p>Returns <code>nil</code> if no changes are made (that is, no duplicates are
found).</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">uniq!</span>   <span class="ruby-comment"># =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>

<span class="ruby-identifier">b</span> = [ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ]
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">uniq!</span>   <span class="ruby-comment"># =&gt; nil</span>

<span class="ruby-identifier">c</span> = [[<span class="ruby-string">&quot;student&quot;</span>,<span class="ruby-string">&quot;sam&quot;</span>], [<span class="ruby-string">&quot;student&quot;</span>,<span class="ruby-string">&quot;george&quot;</span>], [<span class="ruby-string">&quot;teacher&quot;</span>,<span class="ruby-string">&quot;matz&quot;</span>]]
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">uniq!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">first</span> } <span class="ruby-comment"># =&gt; [[&quot;student&quot;, &quot;sam&quot;], [&quot;teacher&quot;, &quot;matz&quot;]]</span>
</pre>
            

            
            <div class="method-source-code" id="uniq-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_uniq_bang(VALUE ary)
{
    VALUE hash;
    long hash_size;

    rb_ary_modify_check(ary);
    if (RARRAY_LEN(ary) &lt;= 1)
        return Qnil;
    if (rb_block_given_p())
        hash = ary_make_hash_by(ary);
    else
        hash = ary_make_hash(ary);

    hash_size = RHASH_SIZE(hash);
    if (RARRAY_LEN(ary) == hash_size) {
        return Qnil;
    }
    rb_ary_modify_check(ary);
    ARY_SET_LEN(ary, 0);
    if (ARY_SHARED_P(ary) &amp;&amp; !ARY_EMBED_P(ary)) {
        rb_ary_unshare(ary);
        FL_SET_EMBED(ary);
    }
    ary_resize_capa(ary, hash_size);
    st_foreach(rb_hash_tbl_raw(hash), push_value, ary);
    ary_recycle_hash(hash);

    return ary;
}
            </pre> 
            </div><!-- uniq-21-source -->
            
          </div>

          

          
        </div><!-- uniq-21-method -->
      
        <div id="unshift-method" class="method-detail ">
          <a name="method-i-unshift"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">unshift(obj, ...)  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Prepends objects to the front of <code>self</code>, moving other elements
upwards. See also <a href="Array.html#method-i-shift">#shift</a> for the
opposite effect.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span> ]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-string">&quot;a&quot;</span>)   <span class="ruby-comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="unshift-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_unshift_m(int argc, VALUE *argv, VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE target_ary;

    if (argc == 0) {
        rb_ary_modify_check(ary);
        return ary;
    }

    target_ary = ary_ensure_room_for_unshift(ary, argc);
    ary_memcpy0(ary, 0, argc, argv, target_ary);
    ARY_SET_LEN(ary, len + argc);
    return ary;
}
            </pre> 
            </div><!-- unshift-source -->
            
          </div>

          

          
        </div><!-- unshift-method -->
      
        <div id="values_at-method" class="method-detail ">
          <a name="method-i-values_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">values_at(selector, ...)  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array containing the elements in <code>self</code> corresponding
to the given <code>selector</code>(s).</p>

<p>The selectors may be either integer indices or ranges.</p>

<p>See also <a href="Array.html#method-i-select">#select</a>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w{ a b c d e f }</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">5</span>)          <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;d&quot;, &quot;f&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">1</span>, <span class="ruby-value">3</span>, <span class="ruby-value">5</span>, <span class="ruby-value">7</span>)       <span class="ruby-comment"># =&gt; [&quot;b&quot;, &quot;d&quot;, &quot;f&quot;, nil]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">-1</span>, <span class="ruby-value">-2</span>, <span class="ruby-value">-2</span>, <span class="ruby-value">-7</span>)   <span class="ruby-comment"># =&gt; [&quot;f&quot;, &quot;e&quot;, &quot;e&quot;, nil]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>, <span class="ruby-value">3</span><span class="ruby-operator">...</span><span class="ruby-value">6</span>)      <span class="ruby-comment"># =&gt; [&quot;e&quot;, &quot;f&quot;, nil, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="values_at-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_values_at(int argc, VALUE *argv, VALUE ary)
{
    return rb_get_values_at(ary, RARRAY_LEN(ary), argc, argv, rb_ary_entry);
}
            </pre> 
            </div><!-- values_at-source -->
            
          </div>

          

          
        </div><!-- values_at-method -->
      
        <div id="zip-method" class="method-detail ">
          <a name="method-i-zip"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...)                  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...) { |arr| block }  &rarr; nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Converts any arguments to arrays, then merges elements of <code>self</code>
with corresponding elements from each argument.</p>

<p>This generates a sequence of <code>ary.size</code> <em>n</em>-element
arrays, where <em>n</em> is one more than the count of arguments.</p>

<p>If the size of any argument is less than the size of the initial array,
<code>nil</code> values are supplied.</p>

<p>If a block is given, it is invoked for each output <code>array</code>,
otherwise an array of arrays is returned.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ]
<span class="ruby-identifier">b</span> = [ <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span> ]
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)   <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)      <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">8</span>])    <span class="ruby-comment">#=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]</span>
</pre>
            

            
            <div class="method-source-code" id="zip-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_zip(int argc, VALUE *argv, VALUE ary)
{
    int i, j;
    long len = RARRAY_LEN(ary);
    VALUE result = Qnil;

    for (i=0; i&lt;argc; i++) {
        argv[i] = take_items(argv[i], len);
    }

    if (rb_block_given_p()) {
        int arity = rb_block_arity();

        if (arity &gt; 1) {
            VALUE work, *tmp;

            tmp = ALLOCV_N(VALUE, work, argc+1);

            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                tmp[0] = RARRAY_AREF(ary, i);
                for (j=0; j&lt;argc; j++) {
                    tmp[j+1] = rb_ary_elt(argv[j], i);
                }
                rb_yield_values2(argc+1, tmp);
            }

            if (work) ALLOCV_END(work);
        }
        else {
            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                VALUE tmp = rb_ary_new2(argc+1);

                rb_ary_push(tmp, RARRAY_AREF(ary, i));
                for (j=0; j&lt;argc; j++) {
                    rb_ary_push(tmp, rb_ary_elt(argv[j], i));
                }
                rb_yield(tmp);
            }
        }
    }
    else {
        result = rb_ary_new_capa(len);

        for (i=0; i&lt;len; i++) {
            VALUE tmp = rb_ary_new_capa(argc+1);

            rb_ary_push(tmp, RARRAY_AREF(ary, i));
            for (j=0; j&lt;argc; j++) {
                rb_ary_push(tmp, rb_ary_elt(argv[j], i));
            }
            rb_ary_push(result, tmp);
        }
    }

    return result;
}
            </pre> 
            </div><!-- zip-source -->
            
          </div>

          

          
        </div><!-- zip-method -->
      
        <div id="7C-method" class="method-detail ">
          <a name="method-i-7C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary | other_ary     &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Set Union — Returns a new array by joining <code>ary</code> with
<code>other_ary</code>, excluding any duplicates and preserving the order
from the original array.</p>

<p>It compares elements using their <a
href="Array.html#method-i-hash">hash</a> and <a
href="Array.html#method-i-eql-3F">eql?</a> methods for efficiency.</p>

<pre class="ruby">[ <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span> ] <span class="ruby-operator">|</span> [ <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;a&quot;</span> ]    <span class="ruby-comment">#=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</span>
</pre>

<p>See also <a href="Array.html#method-i-uniq">#uniq</a>.</p>
            

            
            <div class="method-source-code" id="7C-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_ary_or(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3;
    long i;

    ary2 = to_ary(ary2);
    hash = ary_make_hash(ary1);

    for (i=0; i&lt;RARRAY_LEN(ary2); i++) {
        VALUE elt = RARRAY_AREF(ary2, i);
        if (!st_update(RHASH_TBL_RAW(hash), (st_data_t)elt, ary_hash_orset, (st_data_t)elt)) {
            RB_OBJ_WRITTEN(hash, Qundef, elt);
        }
    }
    ary3 = rb_hash_values(hash);
    ary_recycle_hash(hash);
    return ary3;
}
            </pre> 
            </div><!-- 7C-source -->
            
          </div>

          

          
        </div><!-- 7C-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_Array_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Array_versioned").load("/associated/2.2.2/Array.html");</script> <div id='tx_Array' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Array").load("/associated/Array.html");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 2.2.2</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is a service of <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>, a <a href="http://neurogami.com">software development company in Scottsdale, AZ</a>.</p>
 
    <p><small>Generated with Ruby-doc Rdoc Generator 0.33.0</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
		var img_h = $("img.carbonad-image").css('height');
		//if(img_h != undefined) { //---
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
		//} // ---
	} // end loadPlusdocs


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2.2.2/plus_Array.html', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);
		});
</script>
		
</body>
</html>


