<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.33.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : Encoding::Converter  -   Ruby 2.2.2 ' />
  <meta content="2015-04-26 10:44:36 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = '..'  ENV['RDOC_FOR_WEBSITE']   = false-->
    
  <!-- rel_prefix = '..'   asset_rel_prefix = '..'  --> 
  <title>Class: Encoding::Converter (Ruby 2.2.2) </title>
  <!-- link rel="stylesheet" href="..css/obf.css"  -->
  <link rel="stylesheet" href="../css/inuit.css" >
  <link rel="stylesheet" href="../css/grid.inuit.css" >
  <link rel="stylesheet" href="../css/2011.css" type="text/css" >
  <link rel="stylesheet" href="../css/rdoc.css" type="text/css" >

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="../js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

</head>

<body id="top" class="class rdocstar">
<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
<!-- VERSION HEADER for 2.2.2 NOT FOUND --></div> <!-- end action bar -->
 <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>encoding.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="../Data.html">Data</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-asciicompat_encoding">::asciicompat_encoding</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-search_convpath">::search_convpath</a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-convert">#convert</a></li>
          
          <li><a href="#method-i-convpath">#convpath</a></li>
          
          <li><a href="#method-i-destination_encoding">#destination_encoding</a></li>
          
          <li><a href="#method-i-finish">#finish</a></li>
          
          <li><a href="#method-i-insert_output">#insert_output</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-last_error">#last_error</a></li>
          
          <li><a href="#method-i-primitive_convert">#primitive_convert</a></li>
          
          <li><a href="#method-i-primitive_errinfo">#primitive_errinfo</a></li>
          
          <li><a href="#method-i-putback">#putback</a></li>
          
          <li><a href="#method-i-replacement">#replacement</a></li>
          
          <li><a href="#method-i-replacement-3D">#replacement=</a></li>
          
          <li><a href="#method-i-source_encoding">#source_encoding</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id='files'>
        
          
          <li class="file"><a href="../_lib/racc/rdoc/grammar_en_rdoc.html">grammar.en.rdoc</a></li>
        
          
          <li class="file"><a href="../_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/contributing_rdoc.html">contributing.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/contributors_rdoc.html">contributors.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/dtrace_probes_rdoc.html">dtrace_probes.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/globals_rdoc.html">globals.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/keywords_rdoc.html">keywords.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/maintainers_rdoc.html">maintainers.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/marshal_rdoc.html">marshal.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/regexp_rdoc.html">regexp.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/security_rdoc.html">security.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/standard_library_rdoc.html">standard_library.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax_rdoc.html">syntax.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/assignment_rdoc.html">assignment.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/calling_methods_rdoc.html">calling_methods.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/control_expressions_rdoc.html">control_expressions.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/exceptions_rdoc.html">exceptions.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/literals_rdoc.html">literals.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/methods_rdoc.html">methods.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/miscellaneous_rdoc.html">miscellaneous.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/modules_and_classes_rdoc.html">modules_and_classes.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/precedence_rdoc.html">precedence.rdoc</a></li>
        
          
          <li class="file"><a href="../doc/syntax/refinements_rdoc.html">refinements.rdoc</a></li>
        
          
          <li class="file"><a href="../sample/drb/README_ja_rdoc.html">README.ja.rdoc</a></li>
        
          
          <li class="file"><a href="../sample/drb/README_rdoc.html">README.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="../ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="../Array.html">Array</a></li>
        
          
          
          <li><a href="../BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="../Bignum.html">Bignum</a></li>
        
          
          
          <li><a href="../Binding.html">Binding</a></li>
        
          
          
          <li><a href="../Class.html">Class</a></li>
        
          
          
          <li><a href="../Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="../Complex.html">Complex</a></li>
        
          
          
          <li><a href="../Complex/compatible.html">Complex::compatible</a></li>
        
          
          
          <li><a href="../ConditionVariable.html">ConditionVariable</a></li>
        
          
          
          <li><a href="../Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="../Data.html">Data</a></li>
        
          
          
          <li><a href="../Dir.html">Dir</a></li>
        
          
          
          <li><a href="../ENV.html">ENV</a></li>
        
          
          
          <li><a href="../EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="../Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="../Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="../Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="../Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="../Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="../Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="../EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="../Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="../Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="../Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="../Enumerator/Lazy.html">Enumerator::Lazy</a></li>
        
          
          
          <li><a href="../Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="../Errno.html">Errno</a></li>
        
          
          
          <li><a href="../Exception.html">Exception</a></li>
        
          
          
          <li><a href="../FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="../Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="../FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="../File.html">File</a></li>
        
          
          
          <li><a href="../File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="../File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="../FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="../Fixnum.html">Fixnum</a></li>
        
          
          
          <li><a href="../Float.html">Float</a></li>
        
          
          
          <li><a href="../FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="../GC.html">GC</a></li>
        
          
          
          <li><a href="../GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="../Hash.html">Hash</a></li>
        
          
          
          <li><a href="../IO.html">IO</a></li>
        
          
          
          <li><a href="../IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
        
          
          
          <li><a href="../IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
        
          
          
          <li><a href="../IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
        
          
          
          <li><a href="../IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
        
          
          
          <li><a href="../IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
        
          
          
          <li><a href="../IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
        
          
          
          <li><a href="../IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="../IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="../IOError.html">IOError</a></li>
        
          
          
          <li><a href="../IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="../Integer.html">Integer</a></li>
        
          
          
          <li><a href="../Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="../Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="../KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="../LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="../LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="../Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="../MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="../Math.html">Math</a></li>
        
          
          
          <li><a href="../Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="../Method.html">Method</a></li>
        
          
          
          <li><a href="../Module.html">Module</a></li>
        
          
          
          <li><a href="../Mutex.html">Mutex</a></li>
        
          
          
          <li><a href="../NameError.html">NameError</a></li>
        
          
          
          <li><a href="../NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="../NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="../NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="../NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="../Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="../Object.html">Object</a></li>
        
          
          
          <li><a href="../ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="../ObjectSpace/WeakMap.html">ObjectSpace::WeakMap</a></li>
        
          
          
          <li><a href="../Proc.html">Proc</a></li>
        
          
          
          <li><a href="../Process.html">Process</a></li>
        
          
          
          <li><a href="../Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="../Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="../Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="../Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="../Process/Waiter.html">Process::Waiter</a></li>
        
          
          
          <li><a href="../Queue.html">Queue</a></li>
        
          
          
          <li><a href="../Random.html">Random</a></li>
        
          
          
          <li><a href="../Range.html">Range</a></li>
        
          
          
          <li><a href="../RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="../Rational.html">Rational</a></li>
        
          
          
          <li><a href="../Rational/compatible.html">Rational::compatible</a></li>
        
          
          
          <li><a href="../Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="../RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="../RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="../RubyVM/Env.html">RubyVM::Env</a></li>
        
          
          
          <li><a href="../RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="../RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="../ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="../SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="../Signal.html">Signal</a></li>
        
          
          
          <li><a href="../SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="../SizedQueue.html">SizedQueue</a></li>
        
          
          
          <li><a href="../StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="../StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="../String.html">String</a></li>
        
          
          
          <li><a href="../Struct.html">Struct</a></li>
        
          
          
          <li><a href="../Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="../SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="../SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="../SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="../SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="../Thread.html">Thread</a></li>
        
          
          
          <li><a href="../Thread/Backtrace/Location.html">Thread::Backtrace::Location</a></li>
        
          
          
          <li><a href="../ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="../ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="../Time.html">Time</a></li>
        
          
          
          <li><a href="../TracePoint.html">TracePoint</a></li>
        
          
          
          <li><a href="../TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="../TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="../UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="../UncaughtThrowError.html">UncaughtThrowError</a></li>
        
          
          
          <li><a href="../ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="../fatal.html">fatal</a></li>
        
          
          
          <li><a href="../unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">Encoding::Converter</h1>

    <div id="description" class="description">
      
    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="AFTER_OUTPUT">AFTER_OUTPUT</a></dt>
          
          <dd class="description"><p><a href="Converter.html#AFTER_OUTPUT">AFTER_OUTPUT</a></p>

<p>Stop converting after some output is complete but before all of the input
was consumed.  See <a
href="Converter.html#method-i-primitive_convert">#primitive_convert</a> for
an example.</p></dd>
          
        
          <dt><a name="CRLF_NEWLINE_DECORATOR">CRLF_NEWLINE_DECORATOR</a></dt>
          
          <dd class="description"><p><a href="Converter.html#CRLF_NEWLINE_DECORATOR">CRLF_NEWLINE_DECORATOR</a></p>

<p>Decorator for converting LF to CRLF</p></dd>
          
        
          <dt><a name="CR_NEWLINE_DECORATOR">CR_NEWLINE_DECORATOR</a></dt>
          
          <dd class="description"><p><a href="Converter.html#CR_NEWLINE_DECORATOR">CR_NEWLINE_DECORATOR</a></p>

<p>Decorator for converting LF to CR</p></dd>
          
        
          <dt><a name="INVALID_MASK">INVALID_MASK</a></dt>
          
          <dd class="description"><p><a href="Converter.html#INVALID_MASK">INVALID_MASK</a></p>

<p>Mask for invalid byte sequences</p></dd>
          
        
          <dt><a name="INVALID_REPLACE">INVALID_REPLACE</a></dt>
          
          <dd class="description"><p><a href="Converter.html#INVALID_REPLACE">INVALID_REPLACE</a></p>

<p>Replace invalid byte sequences</p></dd>
          
        
          <dt><a name="PARTIAL_INPUT">PARTIAL_INPUT</a></dt>
          
          <dd class="description"><p><a href="Converter.html#PARTIAL_INPUT">PARTIAL_INPUT</a></p>

<p>Indicates the source may be part of a larger string.  See <a
href="Converter.html#method-i-primitive_convert">#primitive_convert</a> for
an example.</p></dd>
          
        
          <dt><a name="UNDEF_HEX_CHARREF">UNDEF_HEX_CHARREF</a></dt>
          
          <dd class="description"><p><a href="Converter.html#UNDEF_HEX_CHARREF">UNDEF_HEX_CHARREF</a></p>

<p>Replace byte sequences that are undefined in the destination encoding with
an XML hexadecimal character reference.  This is valid for XML conversion.</p></dd>
          
        
          <dt><a name="UNDEF_MASK">UNDEF_MASK</a></dt>
          
          <dd class="description"><p><a href="Converter.html#UNDEF_MASK">UNDEF_MASK</a></p>

<p>Mask for a valid character in the source encoding but no related
character(s) in destination encoding.</p></dd>
          
        
          <dt><a name="UNDEF_REPLACE">UNDEF_REPLACE</a></dt>
          
          <dd class="description"><p><a href="Converter.html#UNDEF_REPLACE">UNDEF_REPLACE</a></p>

<p>Replace byte sequences that are undefined in the destination encoding.</p></dd>
          
        
          <dt><a name="UNIVERSAL_NEWLINE_DECORATOR">UNIVERSAL_NEWLINE_DECORATOR</a></dt>
          
          <dd class="description"><p><a
href="Converter.html#UNIVERSAL_NEWLINE_DECORATOR">UNIVERSAL_NEWLINE_DECORATOR</a></p>

<p>Decorator for converting CRLF and CR to LF</p></dd>
          
        
          <dt><a name="XML_ATTR_CONTENT_DECORATOR">XML_ATTR_CONTENT_DECORATOR</a></dt>
          
          <dd class="description"><p><a
href="Converter.html#XML_ATTR_CONTENT_DECORATOR">XML_ATTR_CONTENT_DECORATOR</a></p>

<p>Escape as XML AttValue</p></dd>
          
        
          <dt><a name="XML_ATTR_QUOTE_DECORATOR">XML_ATTR_QUOTE_DECORATOR</a></dt>
          
          <dd class="description"><p><a
href="Converter.html#XML_ATTR_QUOTE_DECORATOR">XML_ATTR_QUOTE_DECORATOR</a></p>

<p>Escape as XML AttValue</p></dd>
          
        
          <dt><a name="XML_TEXT_DECORATOR">XML_TEXT_DECORATOR</a></dt>
          
          <dd class="description"><p><a href="Converter.html#XML_TEXT_DECORATOR">XML_TEXT_DECORATOR</a></p>

<p>Escape as XML CharData</p></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="asciicompat_encoding-method" class="method-detail ">
          <a name="method-c-asciicompat_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.asciicompat_encoding(string) &rarr; encoding or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.asciicompat_encoding(encoding) &rarr; encoding or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the corresponding ASCII compatible encoding.</p>

<p>Returns nil if the argument is an ASCII compatible encoding.</p>

<p>“corresponding ASCII compatible encoding” is an ASCII compatible encoding
which can represents exactly the same characters as the given ASCII
incompatible encoding. So, no conversion undefined error occurs when
converting between the two encodings.</p>

<pre class="ruby"><span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">asciicompat_encoding</span>(<span class="ruby-string">&quot;ISO-2022-JP&quot;</span>) <span class="ruby-comment">#=&gt; #&lt;Encoding:stateless-ISO-2022-JP&gt;</span>
<span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">asciicompat_encoding</span>(<span class="ruby-string">&quot;UTF-16BE&quot;</span>) <span class="ruby-comment">#=&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">asciicompat_encoding</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>) <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="asciicompat_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_s_asciicompat_encoding(VALUE klass, VALUE arg)
{
    const char *arg_name, *result_name;
    rb_encoding *arg_enc, *result_enc;

    enc_arg(&amp;arg, &amp;arg_name, &amp;arg_enc);

    result_name = rb_econv_asciicompat_encoding(arg_name);

    if (result_name == NULL)
        return Qnil;

    result_enc = make_encoding(result_name);

    return rb_enc_from_encoding(result_enc);
}
            </pre> 
            </div><!-- asciicompat_encoding-source -->
            
          </div>

          

          
        </div><!-- asciicompat_encoding-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.new(source_encoding, destination_encoding)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.new(source_encoding, destination_encoding, opt)</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.new(convpath)</span>
            
          </div>
          
          
          <div>
  
            
            <p>possible options elements:</p>

<pre>hash form:
  :invalid =&gt; nil            # raise error on invalid byte sequence (default)
  :invalid =&gt; :replace       # replace invalid byte sequence
  :undef =&gt; nil              # raise error on undefined conversion (default)
  :undef =&gt; :replace         # replace undefined conversion
  :replace =&gt; string         # replacement string (&quot;?&quot; or &quot;\uFFFD&quot; if not specified)
  :newline =&gt; :universal     # decorator for converting CRLF and CR to LF
  :newline =&gt; :crlf          # decorator for converting LF to CRLF
  :newline =&gt; :cr            # decorator for converting LF to CR
  :universal_newline =&gt; true # decorator for converting CRLF and CR to LF
  :crlf_newline =&gt; true      # decorator for converting LF to CRLF
  :cr_newline =&gt; true        # decorator for converting LF to CR
  :xml =&gt; :text              # escape as XML CharData.
  :xml =&gt; :attr              # escape as XML AttValue
integer form:
  Encoding::Converter::INVALID_REPLACE
  Encoding::Converter::UNDEF_REPLACE
  Encoding::Converter::UNDEF_HEX_CHARREF
  Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR
  Encoding::Converter::CRLF_NEWLINE_DECORATOR
  Encoding::Converter::CR_NEWLINE_DECORATOR
  Encoding::Converter::XML_TEXT_DECORATOR
  Encoding::Converter::XML_ATTR_CONTENT_DECORATOR
  Encoding::Converter::XML_ATTR_QUOTE_DECORATOR</pre>

<p><a href="Converter.html#method-c-new">::new</a> creates an instance of <a
href="Converter.html">Encoding::Converter</a>.</p>

<p>Source_encoding and <a
href="Converter.html#method-i-destination_encoding">#destination_encoding</a>
should be a string or <a href="../Encoding.html">Encoding</a> object.</p>

<p>opt should be nil, a hash or an integer.</p>

<p>convpath should be an array. convpath may contain</p>
<ul><li>
<p>two-element arrays which contain encodings or encoding names, or</p>
</li><li>
<p>strings representing decorator names.</p>
</li></ul>

<p><a href="Converter.html#method-c-new">::new</a> optionally takes an option.
The option should be a hash or an integer. The option hash can contain
:invalid =&gt; nil, etc. The option integer should be logical-or of
constants such as Encoding::Converter::INVALID_REPLACE, etc.</p>
<dl class="rdoc-list label-list"><dt>:invalid =&gt; nil
<dd>
<p>Raise error on invalid byte sequence.  This is a default behavior.</p>
</dd><dt>:invalid =&gt; :replace
<dd>
<p>Replace invalid byte sequence by replacement string.</p>
</dd><dt>:undef =&gt; nil
<dd>
<p>Raise an error if a character in <a
href="Converter.html#method-i-source_encoding">#source_encoding</a> is not
defined in destination_encoding. This is a default behavior.</p>
</dd><dt>:undef =&gt; :replace
<dd>
<p>Replace undefined character in <a
href="Converter.html#method-i-destination_encoding">#destination_encoding</a>
with replacement string.</p>
</dd><dt>:replace =&gt; string
<dd>
<p>Specify the replacement string. If not specified, “uFFFD” is used for
Unicode encodings and “?” for others.</p>
</dd><dt>:universal_newline =&gt; true
<dd>
<p>Convert CRLF and CR to LF.</p>
</dd><dt>:crlf_newline =&gt; true
<dd>
<p>Convert LF to CRLF.</p>
</dd><dt>:cr_newline =&gt; true
<dd>
<p>Convert LF to CR.</p>
</dd><dt>:xml =&gt; :text
<dd>
<p>Escape as XML CharData. This form can be used as a HTML 4.0 #PCDATA.</p>
<ul><li>
<p>‘&amp;’ -&gt; ‘&amp;amp;’</p>
</li><li>
<p>‘&lt;’ -&gt; ‘&amp;lt;’</p>
</li><li>
<p>‘&gt;’ -&gt; ‘&amp;gt;’</p>
</li><li>
<p>undefined characters in <a
href="Converter.html#method-i-destination_encoding">#destination_encoding</a>
-&gt; hexadecimal CharRef such as &amp;#xHH;</p>
</li></ul>
</dd><dt>:xml =&gt; :attr
<dd>
<p>Escape as XML AttValue. The converted result is quoted as “…”. This form
can be used as a HTML 4.0 attribute value.</p>
<ul><li>
<p>‘&amp;’ -&gt; ‘&amp;amp;’</p>
</li><li>
<p>‘&lt;’ -&gt; ‘&amp;lt;’</p>
</li><li>
<p>‘&gt;’ -&gt; ‘&amp;gt;’</p>
</li><li>
<p>‘“’ -&gt; ‘&amp;quot;’</p>
</li><li>
<p>undefined characters in <a
href="Converter.html#method-i-destination_encoding">#destination_encoding</a>
-&gt; hexadecimal CharRef such as &amp;#xHH;</p>
</li></ul>
</dd></dl>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># UTF-16BE to UTF-8</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-16BE&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>)

<span class="ruby-comment"># Usually, decorators such as newline conversion are inserted last.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-16BE&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>, :<span class="ruby-identifier">universal_newline</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convpath</span> <span class="ruby-comment">#=&gt; [[#&lt;Encoding:UTF-16BE&gt;, #&lt;Encoding:UTF-8&gt;],</span>
              <span class="ruby-comment">#    &quot;universal_newline&quot;]</span>

<span class="ruby-comment"># But, if the last encoding is ASCII incompatible,</span>
<span class="ruby-comment"># decorators are inserted before the last conversion.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>, <span class="ruby-string">&quot;UTF-16BE&quot;</span>, :<span class="ruby-identifier">crlf_newline</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convpath</span> <span class="ruby-comment">#=&gt; [&quot;crlf_newline&quot;,</span>
              <span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]</span>

<span class="ruby-comment"># Conversion path can be specified directly.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&quot;universal_newline&quot;</span>, [<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>], [<span class="ruby-string">&quot;UTF-8&quot;</span>, <span class="ruby-string">&quot;UTF-16BE&quot;</span>]])
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convpath</span> <span class="ruby-comment">#=&gt; [&quot;universal_newline&quot;,</span>
              <span class="ruby-comment">#    [#&lt;Encoding:EUC-JP&gt;, #&lt;Encoding:UTF-8&gt;],</span>
              <span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]</span>
</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_init(int argc, VALUE *argv, VALUE self)
{
    VALUE ecopts;
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    rb_econv_t *ec;
    int ecflags;
    VALUE convpath;

    if (rb_check_typeddata(self, &amp;econv_data_type)) {
        rb_raise(rb_eTypeError, &quot;already initialized&quot;);
    }

    if (argc == 1 &amp;&amp; !NIL_P(convpath = rb_check_array_type(argv[0]))) {
        ec = rb_econv_init_by_convpath(self, convpath, &amp;sname, &amp;dname, &amp;senc, &amp;denc);
        ecflags = 0;
        ecopts = Qnil;
    }
    else {
        econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);
        ec = rb_econv_open_opts(sname, dname, ecflags, ecopts);
    }

    if (!ec) {
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));
    }

    if (!DECORATOR_P(sname, dname)) {
        if (!senc)
            senc = make_dummy_encoding(sname);
        if (!denc)
            denc = make_dummy_encoding(dname);
    }

    ec-&gt;source_encoding = senc;
    ec-&gt;destination_encoding = denc;

    DATA_PTR(self) = ec;

    return self;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
        <div id="search_convpath-method" class="method-detail ">
          <a name="method-c-search_convpath"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.search_convpath(source_encoding, destination_encoding)         &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Encoding::Converter.search_convpath(source_encoding, destination_encoding, opt)    &rarr; ary</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a conversion path.</p>

<pre>p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;)
#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;]]

p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, universal_newline: true)
or
p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, newline: :universal)
#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
#    &quot;universal_newline&quot;]

p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;UTF-32BE&quot;, universal_newline: true)
or
p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;UTF-32BE&quot;, newline: :universal)
#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
#    &quot;universal_newline&quot;,
#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-32BE&gt;]]</pre>
            

            
            <div class="method-source-code" id="search_convpath-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_s_search_convpath(int argc, VALUE *argv, VALUE klass)
{
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    int ecflags;
    VALUE ecopts;
    VALUE convpath;

    econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);

    convpath = Qnil;
    transcode_search_path(sname, dname, search_convpath_i, &amp;convpath);

    if (NIL_P(convpath))
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    if (decorate_convpath(convpath, ecflags) == -1)
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    return convpath;
}
            </pre> 
            </div><!-- search_convpath-source -->
            
          </div>

          

          
        </div><!-- search_convpath-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ec == other        &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_equal(VALUE self, VALUE other)
{
    rb_econv_t *ec1 = check_econv(self);
    rb_econv_t *ec2;
    int i;

    if (!rb_typeddata_is_kind_of(other, &amp;econv_data_type)) {
        return Qnil;
    }
    ec2 = DATA_PTR(other);
    if (!ec2) return Qfalse;
    if (ec1-&gt;source_encoding_name != ec2-&gt;source_encoding_name &amp;&amp;
        strcmp(ec1-&gt;source_encoding_name, ec2-&gt;source_encoding_name))
        return Qfalse;
    if (ec1-&gt;destination_encoding_name != ec2-&gt;destination_encoding_name &amp;&amp;
        strcmp(ec1-&gt;destination_encoding_name, ec2-&gt;destination_encoding_name))
        return Qfalse;
    if (ec1-&gt;flags != ec2-&gt;flags) return Qfalse;
    if (ec1-&gt;replacement_enc != ec2-&gt;replacement_enc &amp;&amp;
        strcmp(ec1-&gt;replacement_enc, ec2-&gt;replacement_enc))
        return Qfalse;
    if (ec1-&gt;replacement_len != ec2-&gt;replacement_len) return Qfalse;
    if (ec1-&gt;replacement_str != ec2-&gt;replacement_str &amp;&amp;
        memcmp(ec1-&gt;replacement_str, ec2-&gt;replacement_str, ec2-&gt;replacement_len))
        return Qfalse;

    if (ec1-&gt;num_trans != ec2-&gt;num_trans) return Qfalse;
    for (i = 0; i &lt; ec1-&gt;num_trans; i++) {
        if (ec1-&gt;elems[i].tc-&gt;transcoder != ec2-&gt;elems[i].tc-&gt;transcoder)
            return Qfalse;
    }
    return Qtrue;
}
            </pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->
      
        <div id="convert-method" class="method-detail ">
          <a name="method-i-convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">convert(source_string) &rarr; destination_string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Convert source_string and return destination_string.</p>

<p>source_string is assumed as a part of source. i.e.  :partial_input=&gt;true
is specified internally. finish method should be used last.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;euc-jp&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\u3042&quot;</span>).<span class="ruby-identifier">dump</span>     <span class="ruby-comment">#=&gt; &quot;\xA4\xA2&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">finish</span>.<span class="ruby-identifier">dump</span>                <span class="ruby-comment">#=&gt; &quot;&quot;</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>, <span class="ruby-string">&quot;utf-8&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\xA4&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\xA2&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;\xE3\x81\x82&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">finish</span>.<span class="ruby-identifier">dump</span>                <span class="ruby-comment">#=&gt; &quot;&quot;</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-2022-jp&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\xE3&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\x81&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\x82&quot;</span>).<span class="ruby-identifier">dump</span>       <span class="ruby-comment">#=&gt; &quot;\e$B$\&quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</span>
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">finish</span>.<span class="ruby-identifier">dump</span>                <span class="ruby-comment">#=&gt; &quot;\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;)</span>
</pre>

<p>If a conversion error occur, <a
href="UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
or <a
href="InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
is raised. <a href="Converter.html#method-i-convert">#convert</a> doesn’t
supply methods to recover or restart from these exceptions. When you want
to handle these conversion errors, use <a
href="Converter.html#method-i-primitive_convert">#primitive_convert</a>.</p>
            

            
            <div class="method-source-code" id="convert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_convert(VALUE self, VALUE source_string)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    StringValue(source_string);

    dst = rb_str_new(NULL, 0);

    av[0] = rb_str_dup(source_string);
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(ECONV_PARTIAL_INPUT);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret == sym_finished) {
        rb_raise(rb_eArgError, &quot;converter already finished&quot;);
    }

    if (ret != sym_source_buffer_empty) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}
            </pre> 
            </div><!-- convert-source -->
            
          </div>

          

          
        </div><!-- convert-method -->
      
        <div id="convpath-method" class="method-detail ">
          <a name="method-i-convpath"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">convpath        &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the conversion path of ec.</p>

<p>The result is an array of conversions.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>, <span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-identifier">crlf_newline</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convpath</span>
<span class="ruby-comment">#=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],</span>
<span class="ruby-comment">#    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],</span>
<span class="ruby-comment">#    &quot;crlf_newline&quot;]</span>
</pre>

<p>Each element of the array is a pair of encodings or a string. A pair means
an encoding conversion. A string means a decorator.</p>

<p>In the above example, [#&lt;Encoding:ISO-8859-1&gt;,
#&lt;Encoding:UTF-8&gt;] means a converter from ISO-8859-1 to UTF-8.
“crlf_newline” means newline converter from LF to CRLF.</p>
            

            
            <div class="method-source-code" id="convpath-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_convpath(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE result;
    int i;

    result = rb_ary_new();
    for (i = 0; i &lt; ec-&gt;num_trans; i++) {
        const rb_transcoder *tr = ec-&gt;elems[i].tc-&gt;transcoder;
        VALUE v;
        if (DECORATOR_P(tr-&gt;src_encoding, tr-&gt;dst_encoding))
            v = rb_str_new_cstr(tr-&gt;dst_encoding);
        else
            v = rb_assoc_new(make_encobj(tr-&gt;src_encoding), make_encobj(tr-&gt;dst_encoding));
        rb_ary_push(result, v);
    }
    return result;
}
            </pre> 
            </div><!-- convpath-source -->
            
          </div>

          

          
        </div><!-- convpath-method -->
      
        <div id="destination_encoding-method" class="method-detail ">
          <a name="method-i-destination_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">destination_encoding &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the destination encoding as an <a
href="../Encoding.html">Encoding</a> object.</p>
            

            
            <div class="method-source-code" id="destination_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_destination_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;destination_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;destination_encoding);
}
            </pre> 
            </div><!-- destination_encoding-source -->
            
          </div>

          

          
        </div><!-- destination_encoding-method -->
      
        <div id="finish-method" class="method-detail ">
          <a name="method-i-finish"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">finish &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Finishes the converter. It returns the last part of the converted string.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-2022-jp&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;\u3042&quot;</span>)     <span class="ruby-comment">#=&gt; &quot;\e$B$\&quot;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">finish</span>                <span class="ruby-comment">#=&gt; &quot;\e(B&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="finish-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_finish(VALUE self)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    dst = rb_str_new(NULL, 0);

    av[0] = Qnil;
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2FIX(0);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret != sym_finished) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}
            </pre> 
            </div><!-- finish-source -->
            
          </div>

          

          
        </div><!-- finish-method -->
      
        <div id="insert_output-method" class="method-detail ">
          <a name="method-i-insert_output"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">insert_output(string) &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Inserts string into the encoding converter. The string will be converted to
the destination encoding and output on later conversions.</p>

<p>If the destination encoding is stateful, string is converted according to
the state and the state is updated.</p>

<p>This method should be used only when a conversion error occurs.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-8859-1&quot;</span>)
<span class="ruby-identifier">src</span> = <span class="ruby-string">&quot;HIRAGANA LETTER A is \u{3042}.&quot;</span>
<span class="ruby-identifier">dst</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)    <span class="ruby-comment">#=&gt; :undefined_conversion</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{dst.dump}, #{src.dump}]&quot;</span>   <span class="ruby-comment">#=&gt; [&quot;HIRAGANA LETTER A is &quot;, &quot;.&quot;]</span>
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">insert_output</span>(<span class="ruby-string">&quot;&lt;err&gt;&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)    <span class="ruby-comment">#=&gt; :finished</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{dst.dump}, #{src.dump}]&quot;</span>   <span class="ruby-comment">#=&gt; [&quot;HIRAGANA LETTER A is &lt;err&gt;.&quot;, &quot;&quot;]</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-2022-jp&quot;</span>)
<span class="ruby-identifier">src</span> = <span class="ruby-string">&quot;\u{306F 3041 3068 2661 3002}&quot;</span> <span class="ruby-comment"># U+2661 is not representable in iso-2022-jp</span>
<span class="ruby-identifier">dst</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)    <span class="ruby-comment">#=&gt; :undefined_conversion</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{dst.dump}, #{src.dump}]&quot;</span>   <span class="ruby-comment">#=&gt; [&quot;\e$B$O$!$H&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;\xE3\x80\x82&quot;]</span>
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">insert_output</span> <span class="ruby-string">&quot;?&quot;</span>                <span class="ruby-comment"># state change required to output &quot;?&quot;.</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)    <span class="ruby-comment">#=&gt; :finished</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{dst.dump}, #{src.dump}]&quot;</span>   <span class="ruby-comment">#=&gt; [&quot;\e$B$O$!$H\e(B?\e$B!#\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="insert_output-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_insert_output(VALUE self, VALUE string)
{
    const char *insert_enc;

    int ret;

    rb_econv_t *ec = check_econv(self);

    StringValue(string);
    insert_enc = rb_econv_encoding_to_insert_output(ec);
    string = rb_str_encode(string, rb_enc_from_encoding(rb_enc_find(insert_enc)), 0, Qnil);

    ret = rb_econv_insert_output(ec, (const unsigned char *)RSTRING_PTR(string), RSTRING_LEN(string), insert_enc);
    if (ret == -1) {
        rb_raise(rb_eArgError, &quot;too big string&quot;);
    }

    return Qnil;
}
            </pre> 
            </div><!-- insert_output-source -->
            
          </div>

          

          
        </div><!-- insert_output-method -->
      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect         &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a printable version of <em>ec</em></p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;iso-8859-1&quot;</span>, <span class="ruby-string">&quot;utf-8&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">inspect</span>    <span class="ruby-comment">#=&gt; #&lt;Encoding::Converter: ISO-8859-1 to UTF-8&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_inspect(VALUE self)
{
    const char *cname = rb_obj_classname(self);
    rb_econv_t *ec;

    TypedData_Get_Struct(self, rb_econv_t, &amp;econv_data_type, ec);
    if (!ec)
        return rb_sprintf(&quot;#&lt;%s: uninitialized&gt;&quot;, cname);
    else {
        const char *sname = ec-&gt;source_encoding_name;
        const char *dname = ec-&gt;destination_encoding_name;
        VALUE str;
        str = rb_sprintf(&quot;#&lt;%s: &quot;, cname);
        econv_description(sname, dname, ec-&gt;flags, str);
        rb_str_cat2(str, &quot;&gt;&quot;);
        return str;
    }
}
            </pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->
      
        <div id="last_error-method" class="method-detail ">
          <a name="method-i-last_error"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">last_error &rarr; exception or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an exception object for the last conversion. Returns nil if the
last conversion did not produce an error.</p>

<p>“error” means that <a
href="InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
and <a
href="UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
for <a href="Converter.html#method-i-convert">#convert</a> and
:invalid_byte_sequence, :incomplete_input and :undefined_conversion for <a
href="Converter.html#method-i-primitive_convert">#primitive_convert</a>.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;iso-8859-1&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xf1abcd&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>)       <span class="ruby-comment">#=&gt; :invalid_byte_sequence</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">last_error</span>      <span class="ruby-comment">#=&gt; #&lt;Encoding::InvalidByteSequenceError: &quot;\xF1&quot; followed by &quot;a&quot; on UTF-8&gt;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)             <span class="ruby-comment">#=&gt; :destination_buffer_full</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">last_error</span>      <span class="ruby-comment">#=&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="last_error-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_last_error(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE exc;

    exc = make_econv_exception(ec);
    if (NIL_P(exc))
        return Qnil;
    return exc;
}
            </pre> 
            </div><!-- last_error-source -->
            
          </div>

          

          
        </div><!-- last_error-method -->
      
        <div id="primitive_convert-method" class="method-detail ">
          <a name="method-i-primitive_convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">primitive_convert(source_buffer, destination_buffer) &rarr; symbol</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">primitive_convert(source_buffer, destination_buffer, destination_byteoffset) &rarr; symbol</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) &rarr; symbol</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) &rarr; symbol</span>
            
          </div>
          
          
          <div>
  
            
            <p>possible opt elements:</p>

<pre>hash form:
  :partial_input =&gt; true           # source buffer may be part of larger source
  :after_output =&gt; true            # stop conversion after output before input
integer form:
  Encoding::Converter::PARTIAL_INPUT
  Encoding::Converter::AFTER_OUTPUT</pre>

<p>possible results:</p>

<pre class="ruby">:<span class="ruby-identifier">invalid_byte_sequence</span>
:<span class="ruby-identifier">incomplete_input</span>
:<span class="ruby-identifier">undefined_conversion</span>
:<span class="ruby-identifier">after_output</span>
:<span class="ruby-identifier">destination_buffer_full</span>
:<span class="ruby-identifier">source_buffer_empty</span>
:<span class="ruby-identifier">finished</span>
</pre>

<p><a href="Converter.html#method-i-primitive_convert">#primitive_convert</a>
converts source_buffer into destination_buffer.</p>

<p>source_buffer should be a string or nil. nil means an empty string.</p>

<p>destination_buffer should be a string.</p>

<p>destination_byteoffset should be an integer or nil. nil means the end of
destination_buffer. If it is omitted, nil is assumed.</p>

<p>destination_bytesize should be an integer or nil. nil means unlimited. If
it is omitted, nil is assumed.</p>

<p>opt should be nil, a hash or an integer. nil means no flags. If it is
omitted, nil is assumed.</p>

<p><a href="Converter.html#method-i-primitive_convert">#primitive_convert</a>
converts the content of source_buffer from beginning and store the result
into destination_buffer.</p>

<p>destination_byteoffset and destination_bytesize specify the region which
the converted result is stored. destination_byteoffset specifies the start
position in destination_buffer in bytes. If destination_byteoffset is nil,
destination_buffer.bytesize is used for appending the result.
destination_bytesize specifies maximum number of bytes. If
destination_bytesize is nil, destination size is unlimited. After
conversion, destination_buffer is resized to destination_byteoffset +
actually produced number of bytes. Also destination_buffer’s encoding is
set to destination_encoding.</p>

<p><a href="Converter.html#method-i-primitive_convert">#primitive_convert</a>
drops the converted part of source_buffer. the dropped part is converted in
destination_buffer or buffered in <a
href="Converter.html">Encoding::Converter</a> object.</p>

<p><a href="Converter.html#method-i-primitive_convert">#primitive_convert</a>
stops conversion when one of following condition met.</p>
<ul><li>
<p>invalid byte sequence found in source buffer (:invalid_byte_sequence)
<code>primitive_errinfo</code> and <code>last_error</code> methods returns
the detail of the error.</p>
</li><li>
<p>unexpected end of source buffer (:incomplete_input) this occur only when
:partial_input is not specified. <code>primitive_errinfo</code> and
<code>last_error</code> methods returns the detail of the error.</p>
</li><li>
<p>character not representable in output encoding (:undefined_conversion)
<code>primitive_errinfo</code> and <code>last_error</code> methods returns
the detail of the error.</p>
</li><li>
<p>after some output is generated, before input is done (:after_output) this
occur only when :after_output is specified.</p>
</li><li>
<p>destination buffer is full (:destination_buffer_full) this occur only when
destination_bytesize is non-nil.</p>
</li><li>
<p>source buffer is empty (:source_buffer_empty) this occur only when
:partial_input is specified.</p>
</li><li>
<p>conversion is finished (:finished)</p>
</li></ul>

<p>example:</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>, <span class="ruby-string">&quot;UTF-16BE&quot;</span>)
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;pi&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">100</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:finished, &quot;&quot;, &quot;\x00p\x00i&quot;]</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>, <span class="ruby-string">&quot;UTF-16BE&quot;</span>)
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;pi&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:destination_buffer_full, &quot;i&quot;, &quot;\x00&quot;]</span>
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:destination_buffer_full, &quot;&quot;, &quot;p&quot;]</span>
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:destination_buffer_full, &quot;&quot;, &quot;\x00&quot;]</span>
<span class="ruby-identifier">ret</span> = <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p</span> [<span class="ruby-identifier">ret</span>, <span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>] <span class="ruby-comment">#=&gt; [:finished, &quot;&quot;, &quot;i&quot;]</span>
</pre>
            

            
            <div class="method-source-code" id="primitive_convert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_primitive_convert(int argc, VALUE *argv, VALUE self)
{
    VALUE input, output, output_byteoffset_v, output_bytesize_v, opt, flags_v;
    rb_econv_t *ec = check_econv(self);
    rb_econv_result_t res;
    const unsigned char *ip, *is;
    unsigned char *op, *os;
    long output_byteoffset, output_bytesize;
    unsigned long output_byteend;
    int flags;

    argc = rb_scan_args(argc, argv, &quot;23:&quot;, &amp;input, &amp;output, &amp;output_byteoffset_v, &amp;output_bytesize_v, &amp;flags_v, &amp;opt);

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = 0; /* dummy */
    else
        output_byteoffset = NUM2LONG(output_byteoffset_v);

    if (NIL_P(output_bytesize_v))
        output_bytesize = 0; /* dummy */
    else
        output_bytesize = NUM2LONG(output_bytesize_v);

    if (!NIL_P(flags_v)) {
        if (!NIL_P(opt)) {
            rb_error_arity(argc + 1, 2, 5);
        }
        flags = NUM2INT(rb_to_int(flags_v));
    }
    else if (!NIL_P(opt)) {
        VALUE v;
        flags = 0;
        v = rb_hash_aref(opt, sym_partial_input);
        if (RTEST(v))
            flags |= ECONV_PARTIAL_INPUT;
        v = rb_hash_aref(opt, sym_after_output);
        if (RTEST(v))
            flags |= ECONV_AFTER_OUTPUT;
    }
    else {
        flags = 0;
    }

    StringValue(output);
    if (!NIL_P(input))
        StringValue(input);
    rb_str_modify(output);

    if (NIL_P(output_bytesize_v)) {
        output_bytesize = RSTRING_EMBED_LEN_MAX;
        if (!NIL_P(input) &amp;&amp; output_bytesize &lt; RSTRING_LEN(input))
            output_bytesize = RSTRING_LEN(input);
    }

  retry:

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = RSTRING_LEN(output);

    if (output_byteoffset &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_byteoffset&quot;);

    if (RSTRING_LEN(output) &lt; output_byteoffset)
        rb_raise(rb_eArgError, &quot;output_byteoffset too big&quot;);

    if (output_bytesize &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_bytesize&quot;);

    output_byteend = (unsigned long)output_byteoffset +
                     (unsigned long)output_bytesize;

    if (output_byteend &lt; (unsigned long)output_byteoffset ||
        LONG_MAX &lt; output_byteend)
        rb_raise(rb_eArgError, &quot;output_byteoffset+output_bytesize too big&quot;);

    if (rb_str_capacity(output) &lt; output_byteend)
        rb_str_resize(output, output_byteend);

    if (NIL_P(input)) {
        ip = is = NULL;
    }
    else {
        ip = (const unsigned char *)RSTRING_PTR(input);
        is = ip + RSTRING_LEN(input);
    }

    op = (unsigned char *)RSTRING_PTR(output) + output_byteoffset;
    os = op + output_bytesize;

    res = rb_econv_convert(ec, &amp;ip, is, &amp;op, os, flags);
    rb_str_set_len(output, op-(unsigned char *)RSTRING_PTR(output));
    if (!NIL_P(input))
        rb_str_drop_bytes(input, ip - (unsigned char *)RSTRING_PTR(input));

    if (NIL_P(output_bytesize_v) &amp;&amp; res == econv_destination_buffer_full) {
        if (LONG_MAX / 2 &lt; output_bytesize)
            rb_raise(rb_eArgError, &quot;too long conversion result&quot;);
        output_bytesize *= 2;
        output_byteoffset_v = Qnil;
        goto retry;
    }

    if (ec-&gt;destination_encoding) {
        rb_enc_associate(output, ec-&gt;destination_encoding);
    }

    return econv_result_to_symbol(res);
}
            </pre> 
            </div><!-- primitive_convert-source -->
            
          </div>

          

          
        </div><!-- primitive_convert-method -->
      
        <div id="primitive_errinfo-method" class="method-detail ">
          <a name="method-i-primitive_errinfo"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">primitive_errinfo &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Converter.html#method-i-primitive_errinfo">#primitive_errinfo</a>
returns important information regarding the last error as a 5-element
array:</p>

<pre class="ruby">[<span class="ruby-identifier">result</span>, <span class="ruby-identifier">enc1</span>, <span class="ruby-identifier">enc2</span>, <span class="ruby-identifier">error_bytes</span>, <span class="ruby-identifier">readagain_bytes</span>]
</pre>

<p>result is the last result of primitive_convert.</p>

<p>Other elements are only meaningful when result is :invalid_byte_sequence,
:incomplete_input or :undefined_conversion.</p>

<p>enc1 and enc2 indicate a conversion step as a pair of strings. For example,
a converter from EUC-JP to ISO-8859-1 converts a string as follows: EUC-JP
-&gt; UTF-8 -&gt; ISO-8859-1. So [enc1, enc2] is either [“EUC-JP”, “UTF-8”]
or [“UTF-8”, “ISO-8859-1”].</p>

<p>error_bytes and readagain_bytes indicate the byte sequences which caused
the error. error_bytes is discarded portion. readagain_bytes is buffered
portion which is read again on next conversion.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-comment"># \xff is invalid as EUC-JP.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;Shift_JIS&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xff&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:invalid_byte_sequence, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xFF&quot;, &quot;&quot;]</span>

<span class="ruby-comment"># HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.</span>
<span class="ruby-comment"># Since this error is occur in UTF-8 to ISO-8859-1 conversion,</span>
<span class="ruby-comment"># error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;ISO-8859-1&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xa4\xa2&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:undefined_conversion, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, &quot;\xE3\x81\x82&quot;, &quot;&quot;]</span>

<span class="ruby-comment"># partial character is invalid</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;ISO-8859-1&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xa4&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:incomplete_input, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xA4&quot;, &quot;&quot;]</span>

<span class="ruby-comment"># Encoding::Converter::PARTIAL_INPUT prevents invalid errors by</span>
<span class="ruby-comment"># partial characters.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;EUC-JP&quot;</span>, <span class="ruby-string">&quot;ISO-8859-1&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xa4&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>, <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span><span class="ruby-operator">::</span><span class="ruby-constant">PARTIAL_INPUT</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:source_buffer_empty, nil, nil, nil, nil]</span>

<span class="ruby-comment"># \xd8\x00\x00@ is invalid as UTF-16BE because</span>
<span class="ruby-comment"># no low surrogate after high surrogate (\xd8\x00).</span>
<span class="ruby-comment"># It is detected by 3rd byte (\00) which is part of next character.</span>
<span class="ruby-comment"># So the high surrogate (\xd8\x00) is discarded and</span>
<span class="ruby-comment"># the 3rd byte is read again later.</span>
<span class="ruby-comment"># Since the byte is buffered in ec, it is dropped from src.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-16BE&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\xd8\x00\x00@&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:invalid_byte_sequence, &quot;UTF-16BE&quot;, &quot;UTF-8&quot;, &quot;\xD8\x00&quot;, &quot;\x00&quot;]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">src</span>
<span class="ruby-comment">#=&gt; &quot;@&quot;</span>

<span class="ruby-comment"># Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.</span>
<span class="ruby-comment"># The problem is detected by 4th byte.</span>
<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;UTF-16LE&quot;</span>, <span class="ruby-string">&quot;UTF-8&quot;</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>=<span class="ruby-string">&quot;\x00\xd8@\x00&quot;</span>, <span class="ruby-identifier">dst</span>=<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">10</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>
<span class="ruby-comment">#=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;@\x00&quot;]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">src</span>
<span class="ruby-comment">#=&gt; &quot;&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="primitive_errinfo-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_primitive_errinfo(VALUE self)
{
    rb_econv_t *ec = check_econv(self);

    VALUE ary;

    ary = rb_ary_new2(5);

    rb_ary_store(ary, 0, econv_result_to_symbol(ec-&gt;last_error.result));
    rb_ary_store(ary, 4, Qnil);

    if (ec-&gt;last_error.source_encoding)
        rb_ary_store(ary, 1, rb_str_new2(ec-&gt;last_error.source_encoding));

    if (ec-&gt;last_error.destination_encoding)
        rb_ary_store(ary, 2, rb_str_new2(ec-&gt;last_error.destination_encoding));

    if (ec-&gt;last_error.error_bytes_start) {
        rb_ary_store(ary, 3, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start, ec-&gt;last_error.error_bytes_len));
        rb_ary_store(ary, 4, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start + ec-&gt;last_error.error_bytes_len, ec-&gt;last_error.readagain_len));
    }

    return ary;
}
            </pre> 
            </div><!-- primitive_errinfo-source -->
            
          </div>

          

          
        </div><!-- primitive_errinfo-method -->
      
        <div id="putback-method" class="method-detail ">
          <a name="method-i-putback"></a>

          
          <div class="method-heading">
            <span class="method-name">putback</span><span
              class="method-args">(p1 = v1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>call-seq</p>

<pre>ec.putback                    -&gt; string
ec.putback(max_numbytes)      -&gt; string</pre>

<p>Put back the bytes which will be converted.</p>

<p>The bytes are caused by invalid_byte_sequence error. When
invalid_byte_sequence error, some bytes are discarded and some bytes are
buffered to be converted later. The latter bytes can be put back. It can be
observed by <a
href="InvalidByteSequenceError.html#method-i-readagain_bytes">Encoding::InvalidByteSequenceError#readagain_bytes</a>
and <a
href="Converter.html#method-i-primitive_errinfo">#primitive_errinfo</a>.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-16le&quot;</span>, <span class="ruby-string">&quot;iso-8859-1&quot;</span>)
<span class="ruby-identifier">src</span> = <span class="ruby-string">&quot;\x00\xd8\x61\x00&quot;</span>
<span class="ruby-identifier">dst</span> = <span class="ruby-string">&quot;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_convert</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">dst</span>)   <span class="ruby-comment">#=&gt; :invalid_byte_sequence</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">primitive_errinfo</span>     <span class="ruby-comment">#=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;a\x00&quot;]</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">putback</span>               <span class="ruby-comment">#=&gt; &quot;a\x00&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">putback</span>               <span class="ruby-comment">#=&gt; &quot;&quot;          # no more bytes to put back</span>
</pre>
            

            
            <div class="method-source-code" id="putback-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_putback(int argc, VALUE *argv, VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int n;
    int putbackable;
    VALUE str, max;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;max);

    if (NIL_P(max))
        n = rb_econv_putbackable(ec);
    else {
        n = NUM2INT(max);
        putbackable = rb_econv_putbackable(ec);
        if (putbackable &lt; n)
            n = putbackable;
    }

    str = rb_str_new(NULL, n);
    rb_econv_putback(ec, (unsigned char *)RSTRING_PTR(str), n);

    if (ec-&gt;source_encoding) {
        rb_enc_associate(str, ec-&gt;source_encoding);
    }

    return str;
}
            </pre> 
            </div><!-- putback-source -->
            
          </div>

          

          
        </div><!-- putback-method -->
      
        <div id="replacement-method" class="method-detail ">
          <a name="method-i-replacement"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replacement &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the replacement string.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>, <span class="ruby-string">&quot;us-ascii&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">replacement</span>    <span class="ruby-comment">#=&gt; &quot;?&quot;</span>

<span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;euc-jp&quot;</span>, <span class="ruby-string">&quot;utf-8&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">replacement</span>    <span class="ruby-comment">#=&gt; &quot;\uFFFD&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="replacement-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_get_replacement(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int ret;
    rb_encoding *enc;

    ret = make_replacement(ec);
    if (ret == -1) {
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    enc = rb_enc_find(ec-&gt;replacement_enc);
    return rb_enc_str_new((const char *)ec-&gt;replacement_str, (long)ec-&gt;replacement_len, enc);
}
            </pre> 
            </div><!-- replacement-source -->
            
          </div>

          

          
        </div><!-- replacement-method -->
      
        <div id="replacement-3D-method" class="method-detail ">
          <a name="method-i-replacement-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replacement = string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the replacement string.</p>

<pre class="ruby"><span class="ruby-identifier">ec</span> = <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">Converter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;utf-8&quot;</span>, <span class="ruby-string">&quot;us-ascii&quot;</span>, :<span class="ruby-keyword">undef</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">replace</span>)
<span class="ruby-identifier">ec</span>.<span class="ruby-identifier">replacement</span> = <span class="ruby-string">&quot;&lt;undef&gt;&quot;</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">ec</span>.<span class="ruby-identifier">convert</span>(<span class="ruby-string">&quot;a \u3042 b&quot;</span>)      <span class="ruby-comment">#=&gt; &quot;a &lt;undef&gt; b&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="replacement-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_set_replacement(VALUE self, VALUE arg)
{
    rb_econv_t *ec = check_econv(self);
    VALUE string = arg;
    int ret;
    rb_encoding *enc;

    StringValue(string);
    enc = rb_enc_get(string);

    ret = rb_econv_set_replacement(ec,
            (const unsigned char *)RSTRING_PTR(string),
            RSTRING_LEN(string),
            rb_enc_name(enc));

    if (ret == -1) {
        /* xxx: rb_eInvalidByteSequenceError? */
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    return arg;
}
            </pre> 
            </div><!-- replacement-3D-source -->
            
          </div>

          

          
        </div><!-- replacement-3D-method -->
      
        <div id="source_encoding-method" class="method-detail ">
          <a name="method-i-source_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">source_encoding &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the source encoding as an <a href="../Encoding.html">Encoding</a>
object.</p>
            

            
            <div class="method-source-code" id="source_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
econv_source_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;source_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;source_encoding);
}
            </pre> 
            </div><!-- source_encoding-source -->
            
          </div>

          

          
        </div><!-- source_encoding-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_Converter_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Converter_versioned").load("/associated/2.2.2/Converter.html");</script> <div id='tx_Converter' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Converter").load("/associated/Converter.html");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 2.2.2</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is a service of <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>, an <a href="http://neurogami.com">application development company in Scottsdale, AZ</a>.</p>
 
    <p><small>Generated with Ruby-doc Rdoc Generator 0.33.0</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
		var img_h = $("img.carbonad-image").css('height');
		//if(img_h != undefined) { //---
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
		//} // ---
	} // end loadPlusdocs


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2.2.2/plus_Converter.html', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);
		});
</script>
		
</body>
</html>


